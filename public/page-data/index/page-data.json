{"componentChunkName":"component---gatsby-theme-mdx-deck-src-templates-deck-js","path":"/","matchPath":"/*","webpackCompilationHash":"3cafe79da7213b00da06","result":{"data":{"deck":{"id":"369025ef-a512-5584-9dcc-c6cdccae4bd4","body":"function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsx mdx */\nvar theme = deckTheme;\nvar _frontmatter = {};\n\nvar makeShortcode = function makeShortcode(name) {\n  return function MDXDefaultShortcode(props) {\n    console.warn(\"Component \" + name + \" was not imported, exported, or provided by MDXProvider as global scope\");\n    return mdx(\"div\", props);\n  };\n};\n\nvar layoutProps = {\n  theme: theme,\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, [\"components\"]);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(Head, {\n    mdxType: \"Head\"\n  }, mdx(\"title\", null, \"RxJS - Practice makes Perfect\"), mdx(\"meta\", {\n    name: \"twitter:card\",\n    content: \"summary_large_image\"\n  }), mdx(\"meta\", {\n    name: \"twitter:site\",\n    content: \"@niklas_wortmann\"\n  }), mdx(\"meta\", {\n    name: \"twitter:creator\",\n    content: \"@niklas_wortmann\"\n  }), mdx(\"meta\", {\n    name: \"twitter:title\",\n    content: \"RxJS - Practice makes Perfect\"\n  }), mdx(\"meta\", {\n    name: \"twitter:description\",\n    content: \"Do you want to know how to get into RxJS and especially reactive programming? Check out this presentation.\"\n  }), mdx(\"meta\", {\n    name: \"twitter:image\",\n    content: \"https://rxjs-practice-makes-perfect.dev/static/social-image.png\"\n  }), mdx(\"meta\", {\n    name: \"twitter:image:src\",\n    content: \"https://rxjs-practice-makes-perfect.dev/static/social-image.png\"\n  }), mdx(\"meta\", {\n    name: \"twitter:image:alt\",\n    content: \"Slides to Jan-Niklas Wortmann's talk Practice makes Perfect when it comes to RxJS\"\n  }), mdx(\"meta\", {\n    name: \"description\",\n    content: \"Do you want to know how to get into RxJS and especially reactive programming? Check out this presentation.\"\n  }), mdx(\"meta\", {\n    property: \"og:title\",\n    content: \"RxJS - Practice makes Perfect\"\n  }), mdx(\"meta\", {\n    property: \"og:type\",\n    content: \"website\"\n  }), mdx(\"meta\", {\n    name: \"author\",\n    content: \"Jan-Niklas Wortmann\"\n  }), mdx(\"meta\", {\n    property: \"og:url\",\n    content: \"https://rxjs-practice-makes-perfect.dev\"\n  }), mdx(\"meta\", {\n    property: \"og:image\",\n    content: \"https://rxjs-practice-makes-perfect.dev/static/social-image.png\"\n  }), mdx(\"meta\", {\n    property: \"og:image:secure_url\",\n    content: \"https://rxjs-practice-makes-perfect.dev/static/social-image.png\"\n  }), mdx(\"meta\", {\n    property: \"og:descrtiption\",\n    content: \"Do you want to know how to get into RxJS and especially reactive programming? Check out this presentation.\"\n  })), mdx(ManipulateHead, {\n    mdxType: \"ManipulateHead\"\n  }), mdx(Styles, {\n    mdxType: \"Styles\"\n  }), mdx(\"main\", null, mdx(Title, {\n    mdxType: \"Title\"\n  }), mdx(Footer, {\n    mdxType: \"Footer\"\n  })), mdx(\"hr\", null), mdx(Styles, {\n    mdxType: \"Styles\"\n  }), mdx(\"main\", null, mdx(ImageSplit, {\n    title: \"Do you remember?\",\n    image: bicycleGif,\n    alt: \"a little child trying to ride a bike for the first time and failing unfortunately\",\n    mdxType: \"ImageSplit\"\n  }), mdx(Footer, {\n    mdxType: \"Footer\"\n  })), mdx(\"hr\", null), mdx(Styles, {\n    mdxType: \"Styles\"\n  }), mdx(\"main\", null, mdx(\"div\", {\n    style: {\n      display: 'flex',\n      width: '100%',\n      height: '100%',\n      alignItems: 'center',\n      justifyContent: 'center'\n    }\n  }, mdx(\"h1\", null, \" After a While \")), mdx(Footer, {\n    mdxType: \"Footer\"\n  })), mdx(\"hr\", null), mdx(Styles, {\n    mdxType: \"Styles\"\n  }), mdx(\"main\", null, mdx(\"img\", {\n    src: bicyclePerfectGif,\n    alt: \"a little girl riding a bike and drift perfectly around a corner\",\n    style: {\n      \"width\": \"100%\",\n      \"height\": \"100%\",\n      \"padding\": \"40px\"\n    }\n  })), mdx(\"hr\", null), mdx(Styles, {\n    mdxType: \"Styles\"\n  }), mdx(\"main\", null, mdx(\"div\", {\n    style: {\n      display: 'flex',\n      width: '100%',\n      height: '100%',\n      alignItems: 'center',\n      justifyContent: 'center'\n    }\n  }, mdx(CycleFlowDiagram, {\n    mdxType: \"CycleFlowDiagram\"\n  })), mdx(Footer, {\n    mdxType: \"Footer\"\n  })), mdx(\"hr\", null), mdx(Styles, {\n    mdxType: \"Styles\"\n  }), mdx(\"main\", null, mdx(\"div\", {\n    style: {\n      display: 'flex',\n      width: '100%',\n      height: '100%',\n      alignItems: 'center',\n      justifyContent: 'center'\n    }\n  }, mdx(\"h1\", null, \" About Me \")), mdx(Footer, {\n    mdxType: \"Footer\"\n  })), mdx(\"hr\", null), mdx(Styles, {\n    mdxType: \"Styles\"\n  }), mdx(\"main\", null, mdx(AboutMe, {\n    mdxType: \"AboutMe\"\n  }), mdx(Footer, {\n    mdxType: \"Footer\"\n  })), mdx(\"hr\", null), mdx(Styles, {\n    mdxType: \"Styles\"\n  }), mdx(\"main\", null, mdx(RxJSLive, {\n    mdxType: \"RxJSLive\"\n  }), mdx(Footer, {\n    mdxType: \"Footer\"\n  })), mdx(\"hr\", null), mdx(Styles, {\n    mdxType: \"Styles\"\n  }), mdx(\"main\", null, mdx(\"div\", {\n    style: {\n      width: \"100%\",\n      height: \"100%\",\n      backgroundSize: \"contain\",\n      backgroundPosition: \"50% 50%\",\n      backgroundRepeat: \"no-repeat\",\n      backgroundImage: \"url(\".concat(tagCloudPng, \")\")\n    }\n  })), mdx(\"hr\", null), mdx(Styles, {\n    mdxType: \"Styles\"\n  }), mdx(\"main\", null, mdx(\"div\", {\n    style: {\n      display: 'flex',\n      width: '100%',\n      height: '100%',\n      alignItems: 'center',\n      justifyContent: 'center'\n    }\n  }, mdx(Quote, {\n    mdxType: \"Quote\"\n  })), mdx(Footer, {\n    mdxType: \"Footer\"\n  })), mdx(\"hr\", null), mdx(Styles, {\n    mdxType: \"Styles\"\n  }), mdx(\"main\", null, mdx(Styles, {\n    mdxType: \"Styles\"\n  }), mdx(\"div\", {\n    style: {\n      display: 'flex',\n      width: '100%',\n      height: '100%',\n      alignItems: 'center',\n      justifyContent: 'center'\n    }\n  }, mdx(Text, {\n    mdxType: \"Text\"\n  }, \"Have you ever \", mdx(\"span\", {\n    className: \"primary\",\n    style: {\n      \"display\": \"block\"\n    }\n  }, \"learned\"), \" a foreign language?\")), mdx(Footer, {\n    mdxType: \"Footer\"\n  })), mdx(\"hr\", null), mdx(Styles, {\n    mdxType: \"Styles\"\n  }), mdx(\"main\", null, mdx(Table, {\n    titleLeft: \"German\",\n    titleRight: \"English\",\n    data: [[\"Hallo\", \"hello\"], [\"Banane\", \"banana\"], [\"Code\", \"code\"], [\"Kindergarten\", \"kindergarten\"], [\"Ohrwurm\", \"???\", \"ear worm\"], [\"Dreikäsehoch\", \"???\", \"three cheese high\"]],\n    mdxType: \"Table\"\n  }), mdx(Footer, {\n    mdxType: \"Footer\"\n  })), mdx(\"hr\", null), mdx(Styles, {\n    mdxType: \"Styles\"\n  }), mdx(\"main\", null, mdx(Table, {\n    titleLeft: \"Imperative\",\n    titleRight: \"Reactive\",\n    data: [[\"array[0]\", \"first\"], [\"[...array]\", \"toArray\"], [\"filter\", \"filter\"], [\"map\", \"map\"], [\"getData()\", \"¯\\\\_(ツ)_/¯\", \"getData().subscribe()\"], [\"if\", \"¯\\\\_(ツ)_/¯\", \"???\"]],\n    mdxType: \"Table\"\n  }), mdx(Footer, {\n    mdxType: \"Footer\"\n  })), mdx(\"hr\", null), mdx(Styles, {\n    mdxType: \"Styles\"\n  }), mdx(\"main\", null, mdx(\"div\", {\n    style: {\n      display: 'flex',\n      width: '100%',\n      height: '100%',\n      alignItems: 'center',\n      justifyContent: 'center'\n    }\n  }, mdx(Text, {\n    mdxType: \"Text\"\n  }, \"Thinking \", mdx(\"span\", {\n    className: \"primary\"\n  }, \"reactively\"), \" needs practice!\")), mdx(Footer, {\n    mdxType: \"Footer\"\n  })), mdx(\"hr\", null), mdx(Styles, {\n    mdxType: \"Styles\"\n  }), mdx(\"main\", {\n    style: {\n      textAlign: 'center'\n    }\n  }, mdx(\"h1\", null, \"Live Coding Time\"), mdx(\"img\", {\n    src: liveCodingGif,\n    style: {\n      \"width\": \"100%\",\n      \"height\": \"100%\",\n      \"paddingLeft\": \"4em\",\n      \"paddingRight\": \"4em\",\n      \"paddingBottom\": \"2em\"\n    },\n    alt: \"person furiously typing on the keyboard acting to be a professional software developer\"\n  })), mdx(\"hr\", null), mdx(Styles, {\n    mdxType: \"Styles\"\n  }), mdx(\"main\", null, mdx(\"div\", {\n    style: {\n      display: 'flex',\n      width: '100%',\n      height: '100%',\n      alignItems: 'center',\n      justifyContent: 'center'\n    }\n  }, mdx(WebComponent, {\n    mdxType: \"WebComponent\"\n  }))), mdx(\"hr\", null), mdx(Styles, {\n    mdxType: \"Styles\"\n  }), mdx(\"main\", null, mdx(\"div\", {\n    style: {\n      display: 'flex',\n      width: '100%',\n      height: '100%',\n      alignItems: 'center',\n      justifyContent: 'center'\n    }\n  }, mdx(\"h1\", null, \" Summary of live coding \")), mdx(Footer, {\n    mdxType: \"Footer\"\n  })), mdx(\"hr\", null), mdx(Styles, {\n    mdxType: \"Styles\"\n  }), mdx(\"main\", null, mdx(CodeSurfer, {\n    theme: vsDarkReal,\n    mdxType: \"CodeSurfer\"\n  }, mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-ts\",\n    \"metastring\": \"61:68 file=./code/carousel/src/app/carousel/carousel.component.ts title=\\\"The Swipe Feature\\\"\",\n    \"61:68\": true,\n    \"file\": \"./code/carousel/src/app/carousel/carousel.component.ts\",\n    \"title\": \"\\\"The\",\n    \"Swipe\": true,\n    \"Feature\\\"\": true\n  }), \"import { fromEvent, Subject, merge, interval, race, animationFrameScheduler } from 'rxjs';\\nimport {\\n  AfterContentInit,\\n  Component,\\n  ContentChildren,\\n  ElementRef,\\n  QueryList,\\n  OnInit,\\n  OnDestroy\\n} from '@angular/core';\\nimport {\\n  map,\\n  takeLast,\\n  takeUntil,\\n  tap,\\n  switchMap,\\n  filter,\\n  mapTo,\\n  share,\\n  repeatWhen,\\n  observeOn\\n} from 'rxjs/operators';\\n\\nimport { CarouselItemDirective } from './carousel-item.directive';\\nimport { preventEventPropagation } from './util';\\n\\n@Component({\\n  selector: 'app-carousel',\\n  templateUrl: './carousel.component.html',\\n  styleUrls: ['./carousel.component.scss']\\n})\\nexport class CarouselComponent implements\\n  OnInit, AfterContentInit, OnDestroy {\\n\\n  @ContentChildren(CarouselItemDirective) carouselItems:\\n    QueryList<CarouselItemDirective>;\\n\\n  private readonly DELTA_DIRECTION_COEFFICIENT = -1;\\n  private readonly MOVE_THRESHOLD = 15;\\n  private moveThreshold = 0;\\n  private goToPrevPage = 0;\\n  private goToNextPage = 0;\\n  public active = 1;\\n\\n  private destroyed$ = new Subject<void>();\\n\\n  constructor(private el: ElementRef) {\\n  }\\n\\n  ngOnInit(): void {\\n    const clientWidth = this.el.nativeElement.firstChild.clientWidth;\\n    this.moveThreshold = (clientWidth * this.MOVE_THRESHOLD) / 100;\\n    this.goToPrevPage = -1 * this.moveThreshold - 1;\\n    this.goToNextPage = this.moveThreshold + 1;\\n  }\\n\\n  public ngAfterContentInit(): void {\\n    const nativeElement = this.el.nativeElement;\\n    const items = this.carouselItems.toArray();\\n\\n    const touchStart$ = merge(\\n      fromEvent(nativeElement, 'touchstart').pipe(\\n        preventEventPropagation,\\n        map((event: any) => event.touches[0])\\n      ),\\n      fromEvent(nativeElement, 'mousedown').pipe(\\n        preventEventPropagation\\n      )\\n    ).pipe(\\n      tap((e: Event) => {\\n        items.forEach(item => {\\n          this.animateCarouselItem(item, null, 0);\\n        });\\n      })\\n    );\\n\\n    const touchMove$ = (startEvent) => merge(\\n      fromEvent(nativeElement, 'touchmove').pipe(\\n        preventEventPropagation,\\n        map((event: any) => event.touches[0])),\\n      fromEvent(nativeElement, 'mousemove').pipe(\\n        preventEventPropagation\\n      )\\n    ).pipe(\\n      observeOn(animationFrameScheduler),\\n      takeUntil(\\n        race(\\n          fromEvent(nativeElement, 'touchend'),\\n          fromEvent(nativeElement, 'mouseup')\\n        )\\n      ),\\n      map((event) => event.pageX),\\n      map((pageX) => Math.round(startEvent.pageX - pageX)),\\n      tap(data => {\\n        items.forEach(item => {\\n          const delta = this.DELTA_DIRECTION_COEFFICIENT *\\n            ((this.active - 1) *\\n              this.el.nativeElement.firstChild.clientWidth) - data;\\n          this.animateCarouselItem(item, delta, null);\\n        });\\n      }),\\n      takeLast(1)\\n    );\\n\\n    const swipe$ = touchStart$.pipe(\\n      switchMap((startEvent: TouchEvent) => touchMove$(startEvent)),\\n    );\\n\\n    const leftArrow$ = fromEvent(document, 'keydown').pipe(\\n      filter((event: KeyboardEvent) => event.code === 'KeyA'),\\n      mapTo(this.goToPrevPage)\\n    );\\n\\n    const rightArrow$ = fromEvent(document, 'keydown').pipe(\\n      filter((event: KeyboardEvent) => event.code === 'KeyD'),\\n      mapTo(this.goToNextPage)\\n    );\\n\\n    const events$ =  merge(swipe$, leftArrow$, rightArrow$).pipe(\\n      share()\\n    );\\n\\n    const timer$ = interval(5000).pipe(\\n        takeUntil(events$),\\n        repeatWhen(source => source),\\n        tap(() => {\\n          if (this.active >= items.length) {\\n            this.active = 0;\\n            items.forEach(item => {\\n              this.animateCarouselItem(item, 0, 300);\\n            });\\n          }\\n        }),\\n        mapTo(this.goToNextPage)\\n      );\\n\\n\\n    merge(events$, timer$).pipe(\\n      tap(val => {\\n        if (val > this.moveThreshold && this.active < items.length) {\\n          this.active++;\\n        } else if (val < -1 * this.moveThreshold && this.active > 1) {\\n          this.active--;\\n        }\\n\\n        items.forEach(item => {\\n          const delta = this.DELTA_DIRECTION_COEFFICIENT *\\n            ((this.active - 1) *\\n              this.el.nativeElement.firstChild.clientWidth);\\n          this.animateCarouselItem(item, delta, 300);\\n        });\\n      }),\\n      takeUntil(this.destroyed$)\\n    ).subscribe();\\n  }\\n\\n  private animateCarouselItem(\\n    item: CarouselItemDirective,\\n    delta?: number,\\n    transitionTime?: number\\n  ): void {\\n    if (!!transitionTime) {\\n      item.setTransition(transitionTime);\\n    }\\n    if (!!delta || delta === 0) {\\n      item.setStyle('transform', `translateX(${delta}px)`);\\n    }\\n  }\\n\\n  public ngOnDestroy() {\\n    this.destroyed$.next();\\n    this.destroyed$.complete();\\n  }\\n}\\n\")), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-ts\",\n    \"metastring\": \"104:107 file=./code/carousel/src/app/carousel/carousel.component.ts title=\\\"Map To move observable\\\"\",\n    \"104:107\": true,\n    \"file\": \"./code/carousel/src/app/carousel/carousel.component.ts\",\n    \"title\": \"\\\"Map\",\n    \"To\": true,\n    \"move\": true,\n    \"observable\\\"\": true\n  }), \"import { fromEvent, Subject, merge, interval, race, animationFrameScheduler } from 'rxjs';\\nimport {\\n  AfterContentInit,\\n  Component,\\n  ContentChildren,\\n  ElementRef,\\n  QueryList,\\n  OnInit,\\n  OnDestroy\\n} from '@angular/core';\\nimport {\\n  map,\\n  takeLast,\\n  takeUntil,\\n  tap,\\n  switchMap,\\n  filter,\\n  mapTo,\\n  share,\\n  repeatWhen,\\n  observeOn\\n} from 'rxjs/operators';\\n\\nimport { CarouselItemDirective } from './carousel-item.directive';\\nimport { preventEventPropagation } from './util';\\n\\n@Component({\\n  selector: 'app-carousel',\\n  templateUrl: './carousel.component.html',\\n  styleUrls: ['./carousel.component.scss']\\n})\\nexport class CarouselComponent implements\\n  OnInit, AfterContentInit, OnDestroy {\\n\\n  @ContentChildren(CarouselItemDirective) carouselItems:\\n    QueryList<CarouselItemDirective>;\\n\\n  private readonly DELTA_DIRECTION_COEFFICIENT = -1;\\n  private readonly MOVE_THRESHOLD = 15;\\n  private moveThreshold = 0;\\n  private goToPrevPage = 0;\\n  private goToNextPage = 0;\\n  public active = 1;\\n\\n  private destroyed$ = new Subject<void>();\\n\\n  constructor(private el: ElementRef) {\\n  }\\n\\n  ngOnInit(): void {\\n    const clientWidth = this.el.nativeElement.firstChild.clientWidth;\\n    this.moveThreshold = (clientWidth * this.MOVE_THRESHOLD) / 100;\\n    this.goToPrevPage = -1 * this.moveThreshold - 1;\\n    this.goToNextPage = this.moveThreshold + 1;\\n  }\\n\\n  public ngAfterContentInit(): void {\\n    const nativeElement = this.el.nativeElement;\\n    const items = this.carouselItems.toArray();\\n\\n    const touchStart$ = merge(\\n      fromEvent(nativeElement, 'touchstart').pipe(\\n        preventEventPropagation,\\n        map((event: any) => event.touches[0])\\n      ),\\n      fromEvent(nativeElement, 'mousedown').pipe(\\n        preventEventPropagation\\n      )\\n    ).pipe(\\n      tap((e: Event) => {\\n        items.forEach(item => {\\n          this.animateCarouselItem(item, null, 0);\\n        });\\n      })\\n    );\\n\\n    const touchMove$ = (startEvent) => merge(\\n      fromEvent(nativeElement, 'touchmove').pipe(\\n        preventEventPropagation,\\n        map((event: any) => event.touches[0])),\\n      fromEvent(nativeElement, 'mousemove').pipe(\\n        preventEventPropagation\\n      )\\n    ).pipe(\\n      observeOn(animationFrameScheduler),\\n      takeUntil(\\n        race(\\n          fromEvent(nativeElement, 'touchend'),\\n          fromEvent(nativeElement, 'mouseup')\\n        )\\n      ),\\n      map((event) => event.pageX),\\n      map((pageX) => Math.round(startEvent.pageX - pageX)),\\n      tap(data => {\\n        items.forEach(item => {\\n          const delta = this.DELTA_DIRECTION_COEFFICIENT *\\n            ((this.active - 1) *\\n              this.el.nativeElement.firstChild.clientWidth) - data;\\n          this.animateCarouselItem(item, delta, null);\\n        });\\n      }),\\n      takeLast(1)\\n    );\\n\\n    const swipe$ = touchStart$.pipe(\\n      switchMap((startEvent: TouchEvent) => touchMove$(startEvent)),\\n    );\\n\\n    const leftArrow$ = fromEvent(document, 'keydown').pipe(\\n      filter((event: KeyboardEvent) => event.code === 'KeyA'),\\n      mapTo(this.goToPrevPage)\\n    );\\n\\n    const rightArrow$ = fromEvent(document, 'keydown').pipe(\\n      filter((event: KeyboardEvent) => event.code === 'KeyD'),\\n      mapTo(this.goToNextPage)\\n    );\\n\\n    const events$ =  merge(swipe$, leftArrow$, rightArrow$).pipe(\\n      share()\\n    );\\n\\n    const timer$ = interval(5000).pipe(\\n        takeUntil(events$),\\n        repeatWhen(source => source),\\n        tap(() => {\\n          if (this.active >= items.length) {\\n            this.active = 0;\\n            items.forEach(item => {\\n              this.animateCarouselItem(item, 0, 300);\\n            });\\n          }\\n        }),\\n        mapTo(this.goToNextPage)\\n      );\\n\\n\\n    merge(events$, timer$).pipe(\\n      tap(val => {\\n        if (val > this.moveThreshold && this.active < items.length) {\\n          this.active++;\\n        } else if (val < -1 * this.moveThreshold && this.active > 1) {\\n          this.active--;\\n        }\\n\\n        items.forEach(item => {\\n          const delta = this.DELTA_DIRECTION_COEFFICIENT *\\n            ((this.active - 1) *\\n              this.el.nativeElement.firstChild.clientWidth);\\n          this.animateCarouselItem(item, delta, 300);\\n        });\\n      }),\\n      takeUntil(this.destroyed$)\\n    ).subscribe();\\n  }\\n\\n  private animateCarouselItem(\\n    item: CarouselItemDirective,\\n    delta?: number,\\n    transitionTime?: number\\n  ): void {\\n    if (!!transitionTime) {\\n      item.setTransition(transitionTime);\\n    }\\n    if (!!delta || delta === 0) {\\n      item.setStyle('transform', `translateX(${delta}px)`);\\n    }\\n  }\\n\\n  public ngOnDestroy() {\\n    this.destroyed$.next();\\n    this.destroyed$.complete();\\n  }\\n}\\n\")), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-ts\",\n    \"metastring\": \"77:83 file=./code/carousel/src/app/carousel/carousel.component.ts title=\\\"Combine touch and mouse move\\\"\",\n    \"77:83\": true,\n    \"file\": \"./code/carousel/src/app/carousel/carousel.component.ts\",\n    \"title\": \"\\\"Combine\",\n    \"touch\": true,\n    \"and\": true,\n    \"mouse\": true,\n    \"move\\\"\": true\n  }), \"import { fromEvent, Subject, merge, interval, race, animationFrameScheduler } from 'rxjs';\\nimport {\\n  AfterContentInit,\\n  Component,\\n  ContentChildren,\\n  ElementRef,\\n  QueryList,\\n  OnInit,\\n  OnDestroy\\n} from '@angular/core';\\nimport {\\n  map,\\n  takeLast,\\n  takeUntil,\\n  tap,\\n  switchMap,\\n  filter,\\n  mapTo,\\n  share,\\n  repeatWhen,\\n  observeOn\\n} from 'rxjs/operators';\\n\\nimport { CarouselItemDirective } from './carousel-item.directive';\\nimport { preventEventPropagation } from './util';\\n\\n@Component({\\n  selector: 'app-carousel',\\n  templateUrl: './carousel.component.html',\\n  styleUrls: ['./carousel.component.scss']\\n})\\nexport class CarouselComponent implements\\n  OnInit, AfterContentInit, OnDestroy {\\n\\n  @ContentChildren(CarouselItemDirective) carouselItems:\\n    QueryList<CarouselItemDirective>;\\n\\n  private readonly DELTA_DIRECTION_COEFFICIENT = -1;\\n  private readonly MOVE_THRESHOLD = 15;\\n  private moveThreshold = 0;\\n  private goToPrevPage = 0;\\n  private goToNextPage = 0;\\n  public active = 1;\\n\\n  private destroyed$ = new Subject<void>();\\n\\n  constructor(private el: ElementRef) {\\n  }\\n\\n  ngOnInit(): void {\\n    const clientWidth = this.el.nativeElement.firstChild.clientWidth;\\n    this.moveThreshold = (clientWidth * this.MOVE_THRESHOLD) / 100;\\n    this.goToPrevPage = -1 * this.moveThreshold - 1;\\n    this.goToNextPage = this.moveThreshold + 1;\\n  }\\n\\n  public ngAfterContentInit(): void {\\n    const nativeElement = this.el.nativeElement;\\n    const items = this.carouselItems.toArray();\\n\\n    const touchStart$ = merge(\\n      fromEvent(nativeElement, 'touchstart').pipe(\\n        preventEventPropagation,\\n        map((event: any) => event.touches[0])\\n      ),\\n      fromEvent(nativeElement, 'mousedown').pipe(\\n        preventEventPropagation\\n      )\\n    ).pipe(\\n      tap((e: Event) => {\\n        items.forEach(item => {\\n          this.animateCarouselItem(item, null, 0);\\n        });\\n      })\\n    );\\n\\n    const touchMove$ = (startEvent) => merge(\\n      fromEvent(nativeElement, 'touchmove').pipe(\\n        preventEventPropagation,\\n        map((event: any) => event.touches[0])),\\n      fromEvent(nativeElement, 'mousemove').pipe(\\n        preventEventPropagation\\n      )\\n    ).pipe(\\n      observeOn(animationFrameScheduler),\\n      takeUntil(\\n        race(\\n          fromEvent(nativeElement, 'touchend'),\\n          fromEvent(nativeElement, 'mouseup')\\n        )\\n      ),\\n      map((event) => event.pageX),\\n      map((pageX) => Math.round(startEvent.pageX - pageX)),\\n      tap(data => {\\n        items.forEach(item => {\\n          const delta = this.DELTA_DIRECTION_COEFFICIENT *\\n            ((this.active - 1) *\\n              this.el.nativeElement.firstChild.clientWidth) - data;\\n          this.animateCarouselItem(item, delta, null);\\n        });\\n      }),\\n      takeLast(1)\\n    );\\n\\n    const swipe$ = touchStart$.pipe(\\n      switchMap((startEvent: TouchEvent) => touchMove$(startEvent)),\\n    );\\n\\n    const leftArrow$ = fromEvent(document, 'keydown').pipe(\\n      filter((event: KeyboardEvent) => event.code === 'KeyA'),\\n      mapTo(this.goToPrevPage)\\n    );\\n\\n    const rightArrow$ = fromEvent(document, 'keydown').pipe(\\n      filter((event: KeyboardEvent) => event.code === 'KeyD'),\\n      mapTo(this.goToNextPage)\\n    );\\n\\n    const events$ =  merge(swipe$, leftArrow$, rightArrow$).pipe(\\n      share()\\n    );\\n\\n    const timer$ = interval(5000).pipe(\\n        takeUntil(events$),\\n        repeatWhen(source => source),\\n        tap(() => {\\n          if (this.active >= items.length) {\\n            this.active = 0;\\n            items.forEach(item => {\\n              this.animateCarouselItem(item, 0, 300);\\n            });\\n          }\\n        }),\\n        mapTo(this.goToNextPage)\\n      );\\n\\n\\n    merge(events$, timer$).pipe(\\n      tap(val => {\\n        if (val > this.moveThreshold && this.active < items.length) {\\n          this.active++;\\n        } else if (val < -1 * this.moveThreshold && this.active > 1) {\\n          this.active--;\\n        }\\n\\n        items.forEach(item => {\\n          const delta = this.DELTA_DIRECTION_COEFFICIENT *\\n            ((this.active - 1) *\\n              this.el.nativeElement.firstChild.clientWidth);\\n          this.animateCarouselItem(item, delta, 300);\\n        });\\n      }),\\n      takeUntil(this.destroyed$)\\n    ).subscribe();\\n  }\\n\\n  private animateCarouselItem(\\n    item: CarouselItemDirective,\\n    delta?: number,\\n    transitionTime?: number\\n  ): void {\\n    if (!!transitionTime) {\\n      item.setTransition(transitionTime);\\n    }\\n    if (!!delta || delta === 0) {\\n      item.setStyle('transform', `translateX(${delta}px)`);\\n    }\\n  }\\n\\n  public ngOnDestroy() {\\n    this.destroyed$.next();\\n    this.destroyed$.complete();\\n  }\\n}\\n\")), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"85\": true,\n    \"className\": \"language-ts\",\n    \"metastring\": \"85 file=./code/carousel/src/app/carousel/carousel.component.ts title=\\\"Performance Tweak by using animationFrameScheduler\\\"\",\n    \"file\": \"./code/carousel/src/app/carousel/carousel.component.ts\",\n    \"title\": \"\\\"Performance\",\n    \"Tweak\": true,\n    \"by\": true,\n    \"using\": true,\n    \"animationFrameScheduler\\\"\": true\n  }), \"import { fromEvent, Subject, merge, interval, race, animationFrameScheduler } from 'rxjs';\\nimport {\\n  AfterContentInit,\\n  Component,\\n  ContentChildren,\\n  ElementRef,\\n  QueryList,\\n  OnInit,\\n  OnDestroy\\n} from '@angular/core';\\nimport {\\n  map,\\n  takeLast,\\n  takeUntil,\\n  tap,\\n  switchMap,\\n  filter,\\n  mapTo,\\n  share,\\n  repeatWhen,\\n  observeOn\\n} from 'rxjs/operators';\\n\\nimport { CarouselItemDirective } from './carousel-item.directive';\\nimport { preventEventPropagation } from './util';\\n\\n@Component({\\n  selector: 'app-carousel',\\n  templateUrl: './carousel.component.html',\\n  styleUrls: ['./carousel.component.scss']\\n})\\nexport class CarouselComponent implements\\n  OnInit, AfterContentInit, OnDestroy {\\n\\n  @ContentChildren(CarouselItemDirective) carouselItems:\\n    QueryList<CarouselItemDirective>;\\n\\n  private readonly DELTA_DIRECTION_COEFFICIENT = -1;\\n  private readonly MOVE_THRESHOLD = 15;\\n  private moveThreshold = 0;\\n  private goToPrevPage = 0;\\n  private goToNextPage = 0;\\n  public active = 1;\\n\\n  private destroyed$ = new Subject<void>();\\n\\n  constructor(private el: ElementRef) {\\n  }\\n\\n  ngOnInit(): void {\\n    const clientWidth = this.el.nativeElement.firstChild.clientWidth;\\n    this.moveThreshold = (clientWidth * this.MOVE_THRESHOLD) / 100;\\n    this.goToPrevPage = -1 * this.moveThreshold - 1;\\n    this.goToNextPage = this.moveThreshold + 1;\\n  }\\n\\n  public ngAfterContentInit(): void {\\n    const nativeElement = this.el.nativeElement;\\n    const items = this.carouselItems.toArray();\\n\\n    const touchStart$ = merge(\\n      fromEvent(nativeElement, 'touchstart').pipe(\\n        preventEventPropagation,\\n        map((event: any) => event.touches[0])\\n      ),\\n      fromEvent(nativeElement, 'mousedown').pipe(\\n        preventEventPropagation\\n      )\\n    ).pipe(\\n      tap((e: Event) => {\\n        items.forEach(item => {\\n          this.animateCarouselItem(item, null, 0);\\n        });\\n      })\\n    );\\n\\n    const touchMove$ = (startEvent) => merge(\\n      fromEvent(nativeElement, 'touchmove').pipe(\\n        preventEventPropagation,\\n        map((event: any) => event.touches[0])),\\n      fromEvent(nativeElement, 'mousemove').pipe(\\n        preventEventPropagation\\n      )\\n    ).pipe(\\n      observeOn(animationFrameScheduler),\\n      takeUntil(\\n        race(\\n          fromEvent(nativeElement, 'touchend'),\\n          fromEvent(nativeElement, 'mouseup')\\n        )\\n      ),\\n      map((event) => event.pageX),\\n      map((pageX) => Math.round(startEvent.pageX - pageX)),\\n      tap(data => {\\n        items.forEach(item => {\\n          const delta = this.DELTA_DIRECTION_COEFFICIENT *\\n            ((this.active - 1) *\\n              this.el.nativeElement.firstChild.clientWidth) - data;\\n          this.animateCarouselItem(item, delta, null);\\n        });\\n      }),\\n      takeLast(1)\\n    );\\n\\n    const swipe$ = touchStart$.pipe(\\n      switchMap((startEvent: TouchEvent) => touchMove$(startEvent)),\\n    );\\n\\n    const leftArrow$ = fromEvent(document, 'keydown').pipe(\\n      filter((event: KeyboardEvent) => event.code === 'KeyA'),\\n      mapTo(this.goToPrevPage)\\n    );\\n\\n    const rightArrow$ = fromEvent(document, 'keydown').pipe(\\n      filter((event: KeyboardEvent) => event.code === 'KeyD'),\\n      mapTo(this.goToNextPage)\\n    );\\n\\n    const events$ =  merge(swipe$, leftArrow$, rightArrow$).pipe(\\n      share()\\n    );\\n\\n    const timer$ = interval(5000).pipe(\\n        takeUntil(events$),\\n        repeatWhen(source => source),\\n        tap(() => {\\n          if (this.active >= items.length) {\\n            this.active = 0;\\n            items.forEach(item => {\\n              this.animateCarouselItem(item, 0, 300);\\n            });\\n          }\\n        }),\\n        mapTo(this.goToNextPage)\\n      );\\n\\n\\n    merge(events$, timer$).pipe(\\n      tap(val => {\\n        if (val > this.moveThreshold && this.active < items.length) {\\n          this.active++;\\n        } else if (val < -1 * this.moveThreshold && this.active > 1) {\\n          this.active--;\\n        }\\n\\n        items.forEach(item => {\\n          const delta = this.DELTA_DIRECTION_COEFFICIENT *\\n            ((this.active - 1) *\\n              this.el.nativeElement.firstChild.clientWidth);\\n          this.animateCarouselItem(item, delta, 300);\\n        });\\n      }),\\n      takeUntil(this.destroyed$)\\n    ).subscribe();\\n  }\\n\\n  private animateCarouselItem(\\n    item: CarouselItemDirective,\\n    delta?: number,\\n    transitionTime?: number\\n  ): void {\\n    if (!!transitionTime) {\\n      item.setTransition(transitionTime);\\n    }\\n    if (!!delta || delta === 0) {\\n      item.setStyle('transform', `translateX(${delta}px)`);\\n    }\\n  }\\n\\n  public ngOnDestroy() {\\n    this.destroyed$.next();\\n    this.destroyed$.complete();\\n  }\\n}\\n\")), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-ts\",\n    \"metastring\": \"86:91 file=./code/carousel/src/app/carousel/carousel.component.ts title=\\\"don't forget to unsubscribe\\\"\",\n    \"86:91\": true,\n    \"file\": \"./code/carousel/src/app/carousel/carousel.component.ts\",\n    \"title\": \"\\\"don't\",\n    \"forget\": true,\n    \"to\": true,\n    \"unsubscribe\\\"\": true\n  }), \"import { fromEvent, Subject, merge, interval, race, animationFrameScheduler } from 'rxjs';\\nimport {\\n  AfterContentInit,\\n  Component,\\n  ContentChildren,\\n  ElementRef,\\n  QueryList,\\n  OnInit,\\n  OnDestroy\\n} from '@angular/core';\\nimport {\\n  map,\\n  takeLast,\\n  takeUntil,\\n  tap,\\n  switchMap,\\n  filter,\\n  mapTo,\\n  share,\\n  repeatWhen,\\n  observeOn\\n} from 'rxjs/operators';\\n\\nimport { CarouselItemDirective } from './carousel-item.directive';\\nimport { preventEventPropagation } from './util';\\n\\n@Component({\\n  selector: 'app-carousel',\\n  templateUrl: './carousel.component.html',\\n  styleUrls: ['./carousel.component.scss']\\n})\\nexport class CarouselComponent implements\\n  OnInit, AfterContentInit, OnDestroy {\\n\\n  @ContentChildren(CarouselItemDirective) carouselItems:\\n    QueryList<CarouselItemDirective>;\\n\\n  private readonly DELTA_DIRECTION_COEFFICIENT = -1;\\n  private readonly MOVE_THRESHOLD = 15;\\n  private moveThreshold = 0;\\n  private goToPrevPage = 0;\\n  private goToNextPage = 0;\\n  public active = 1;\\n\\n  private destroyed$ = new Subject<void>();\\n\\n  constructor(private el: ElementRef) {\\n  }\\n\\n  ngOnInit(): void {\\n    const clientWidth = this.el.nativeElement.firstChild.clientWidth;\\n    this.moveThreshold = (clientWidth * this.MOVE_THRESHOLD) / 100;\\n    this.goToPrevPage = -1 * this.moveThreshold - 1;\\n    this.goToNextPage = this.moveThreshold + 1;\\n  }\\n\\n  public ngAfterContentInit(): void {\\n    const nativeElement = this.el.nativeElement;\\n    const items = this.carouselItems.toArray();\\n\\n    const touchStart$ = merge(\\n      fromEvent(nativeElement, 'touchstart').pipe(\\n        preventEventPropagation,\\n        map((event: any) => event.touches[0])\\n      ),\\n      fromEvent(nativeElement, 'mousedown').pipe(\\n        preventEventPropagation\\n      )\\n    ).pipe(\\n      tap((e: Event) => {\\n        items.forEach(item => {\\n          this.animateCarouselItem(item, null, 0);\\n        });\\n      })\\n    );\\n\\n    const touchMove$ = (startEvent) => merge(\\n      fromEvent(nativeElement, 'touchmove').pipe(\\n        preventEventPropagation,\\n        map((event: any) => event.touches[0])),\\n      fromEvent(nativeElement, 'mousemove').pipe(\\n        preventEventPropagation\\n      )\\n    ).pipe(\\n      observeOn(animationFrameScheduler),\\n      takeUntil(\\n        race(\\n          fromEvent(nativeElement, 'touchend'),\\n          fromEvent(nativeElement, 'mouseup')\\n        )\\n      ),\\n      map((event) => event.pageX),\\n      map((pageX) => Math.round(startEvent.pageX - pageX)),\\n      tap(data => {\\n        items.forEach(item => {\\n          const delta = this.DELTA_DIRECTION_COEFFICIENT *\\n            ((this.active - 1) *\\n              this.el.nativeElement.firstChild.clientWidth) - data;\\n          this.animateCarouselItem(item, delta, null);\\n        });\\n      }),\\n      takeLast(1)\\n    );\\n\\n    const swipe$ = touchStart$.pipe(\\n      switchMap((startEvent: TouchEvent) => touchMove$(startEvent)),\\n    );\\n\\n    const leftArrow$ = fromEvent(document, 'keydown').pipe(\\n      filter((event: KeyboardEvent) => event.code === 'KeyA'),\\n      mapTo(this.goToPrevPage)\\n    );\\n\\n    const rightArrow$ = fromEvent(document, 'keydown').pipe(\\n      filter((event: KeyboardEvent) => event.code === 'KeyD'),\\n      mapTo(this.goToNextPage)\\n    );\\n\\n    const events$ =  merge(swipe$, leftArrow$, rightArrow$).pipe(\\n      share()\\n    );\\n\\n    const timer$ = interval(5000).pipe(\\n        takeUntil(events$),\\n        repeatWhen(source => source),\\n        tap(() => {\\n          if (this.active >= items.length) {\\n            this.active = 0;\\n            items.forEach(item => {\\n              this.animateCarouselItem(item, 0, 300);\\n            });\\n          }\\n        }),\\n        mapTo(this.goToNextPage)\\n      );\\n\\n\\n    merge(events$, timer$).pipe(\\n      tap(val => {\\n        if (val > this.moveThreshold && this.active < items.length) {\\n          this.active++;\\n        } else if (val < -1 * this.moveThreshold && this.active > 1) {\\n          this.active--;\\n        }\\n\\n        items.forEach(item => {\\n          const delta = this.DELTA_DIRECTION_COEFFICIENT *\\n            ((this.active - 1) *\\n              this.el.nativeElement.firstChild.clientWidth);\\n          this.animateCarouselItem(item, delta, 300);\\n        });\\n      }),\\n      takeUntil(this.destroyed$)\\n    ).subscribe();\\n  }\\n\\n  private animateCarouselItem(\\n    item: CarouselItemDirective,\\n    delta?: number,\\n    transitionTime?: number\\n  ): void {\\n    if (!!transitionTime) {\\n      item.setTransition(transitionTime);\\n    }\\n    if (!!delta || delta === 0) {\\n      item.setStyle('transform', `translateX(${delta}px)`);\\n    }\\n  }\\n\\n  public ngOnDestroy() {\\n    this.destroyed$.next();\\n    this.destroyed$.complete();\\n  }\\n}\\n\")), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-ts\",\n    \"metastring\": \"92:101 file=./code/carousel/src/app/carousel/carousel.component.ts title=\\\"Animate according to move delta\\\"\",\n    \"92:101\": true,\n    \"file\": \"./code/carousel/src/app/carousel/carousel.component.ts\",\n    \"title\": \"\\\"Animate\",\n    \"according\": true,\n    \"to\": true,\n    \"move\": true,\n    \"delta\\\"\": true\n  }), \"import { fromEvent, Subject, merge, interval, race, animationFrameScheduler } from 'rxjs';\\nimport {\\n  AfterContentInit,\\n  Component,\\n  ContentChildren,\\n  ElementRef,\\n  QueryList,\\n  OnInit,\\n  OnDestroy\\n} from '@angular/core';\\nimport {\\n  map,\\n  takeLast,\\n  takeUntil,\\n  tap,\\n  switchMap,\\n  filter,\\n  mapTo,\\n  share,\\n  repeatWhen,\\n  observeOn\\n} from 'rxjs/operators';\\n\\nimport { CarouselItemDirective } from './carousel-item.directive';\\nimport { preventEventPropagation } from './util';\\n\\n@Component({\\n  selector: 'app-carousel',\\n  templateUrl: './carousel.component.html',\\n  styleUrls: ['./carousel.component.scss']\\n})\\nexport class CarouselComponent implements\\n  OnInit, AfterContentInit, OnDestroy {\\n\\n  @ContentChildren(CarouselItemDirective) carouselItems:\\n    QueryList<CarouselItemDirective>;\\n\\n  private readonly DELTA_DIRECTION_COEFFICIENT = -1;\\n  private readonly MOVE_THRESHOLD = 15;\\n  private moveThreshold = 0;\\n  private goToPrevPage = 0;\\n  private goToNextPage = 0;\\n  public active = 1;\\n\\n  private destroyed$ = new Subject<void>();\\n\\n  constructor(private el: ElementRef) {\\n  }\\n\\n  ngOnInit(): void {\\n    const clientWidth = this.el.nativeElement.firstChild.clientWidth;\\n    this.moveThreshold = (clientWidth * this.MOVE_THRESHOLD) / 100;\\n    this.goToPrevPage = -1 * this.moveThreshold - 1;\\n    this.goToNextPage = this.moveThreshold + 1;\\n  }\\n\\n  public ngAfterContentInit(): void {\\n    const nativeElement = this.el.nativeElement;\\n    const items = this.carouselItems.toArray();\\n\\n    const touchStart$ = merge(\\n      fromEvent(nativeElement, 'touchstart').pipe(\\n        preventEventPropagation,\\n        map((event: any) => event.touches[0])\\n      ),\\n      fromEvent(nativeElement, 'mousedown').pipe(\\n        preventEventPropagation\\n      )\\n    ).pipe(\\n      tap((e: Event) => {\\n        items.forEach(item => {\\n          this.animateCarouselItem(item, null, 0);\\n        });\\n      })\\n    );\\n\\n    const touchMove$ = (startEvent) => merge(\\n      fromEvent(nativeElement, 'touchmove').pipe(\\n        preventEventPropagation,\\n        map((event: any) => event.touches[0])),\\n      fromEvent(nativeElement, 'mousemove').pipe(\\n        preventEventPropagation\\n      )\\n    ).pipe(\\n      observeOn(animationFrameScheduler),\\n      takeUntil(\\n        race(\\n          fromEvent(nativeElement, 'touchend'),\\n          fromEvent(nativeElement, 'mouseup')\\n        )\\n      ),\\n      map((event) => event.pageX),\\n      map((pageX) => Math.round(startEvent.pageX - pageX)),\\n      tap(data => {\\n        items.forEach(item => {\\n          const delta = this.DELTA_DIRECTION_COEFFICIENT *\\n            ((this.active - 1) *\\n              this.el.nativeElement.firstChild.clientWidth) - data;\\n          this.animateCarouselItem(item, delta, null);\\n        });\\n      }),\\n      takeLast(1)\\n    );\\n\\n    const swipe$ = touchStart$.pipe(\\n      switchMap((startEvent: TouchEvent) => touchMove$(startEvent)),\\n    );\\n\\n    const leftArrow$ = fromEvent(document, 'keydown').pipe(\\n      filter((event: KeyboardEvent) => event.code === 'KeyA'),\\n      mapTo(this.goToPrevPage)\\n    );\\n\\n    const rightArrow$ = fromEvent(document, 'keydown').pipe(\\n      filter((event: KeyboardEvent) => event.code === 'KeyD'),\\n      mapTo(this.goToNextPage)\\n    );\\n\\n    const events$ =  merge(swipe$, leftArrow$, rightArrow$).pipe(\\n      share()\\n    );\\n\\n    const timer$ = interval(5000).pipe(\\n        takeUntil(events$),\\n        repeatWhen(source => source),\\n        tap(() => {\\n          if (this.active >= items.length) {\\n            this.active = 0;\\n            items.forEach(item => {\\n              this.animateCarouselItem(item, 0, 300);\\n            });\\n          }\\n        }),\\n        mapTo(this.goToNextPage)\\n      );\\n\\n\\n    merge(events$, timer$).pipe(\\n      tap(val => {\\n        if (val > this.moveThreshold && this.active < items.length) {\\n          this.active++;\\n        } else if (val < -1 * this.moveThreshold && this.active > 1) {\\n          this.active--;\\n        }\\n\\n        items.forEach(item => {\\n          const delta = this.DELTA_DIRECTION_COEFFICIENT *\\n            ((this.active - 1) *\\n              this.el.nativeElement.firstChild.clientWidth);\\n          this.animateCarouselItem(item, delta, 300);\\n        });\\n      }),\\n      takeUntil(this.destroyed$)\\n    ).subscribe();\\n  }\\n\\n  private animateCarouselItem(\\n    item: CarouselItemDirective,\\n    delta?: number,\\n    transitionTime?: number\\n  ): void {\\n    if (!!transitionTime) {\\n      item.setTransition(transitionTime);\\n    }\\n    if (!!delta || delta === 0) {\\n      item.setStyle('transform', `translateX(${delta}px)`);\\n    }\\n  }\\n\\n  public ngOnDestroy() {\\n    this.destroyed$.next();\\n    this.destroyed$.complete();\\n  }\\n}\\n\")), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"102\": true,\n    \"className\": \"language-ts\",\n    \"metastring\": \"102 file=./code/carousel/src/app/carousel/carousel.component.ts title=\\\"End Observable and emit last value\\\"\",\n    \"file\": \"./code/carousel/src/app/carousel/carousel.component.ts\",\n    \"title\": \"\\\"End\",\n    \"Observable\": true,\n    \"and\": true,\n    \"emit\": true,\n    \"last\": true,\n    \"value\\\"\": true\n  }), \"import { fromEvent, Subject, merge, interval, race, animationFrameScheduler } from 'rxjs';\\nimport {\\n  AfterContentInit,\\n  Component,\\n  ContentChildren,\\n  ElementRef,\\n  QueryList,\\n  OnInit,\\n  OnDestroy\\n} from '@angular/core';\\nimport {\\n  map,\\n  takeLast,\\n  takeUntil,\\n  tap,\\n  switchMap,\\n  filter,\\n  mapTo,\\n  share,\\n  repeatWhen,\\n  observeOn\\n} from 'rxjs/operators';\\n\\nimport { CarouselItemDirective } from './carousel-item.directive';\\nimport { preventEventPropagation } from './util';\\n\\n@Component({\\n  selector: 'app-carousel',\\n  templateUrl: './carousel.component.html',\\n  styleUrls: ['./carousel.component.scss']\\n})\\nexport class CarouselComponent implements\\n  OnInit, AfterContentInit, OnDestroy {\\n\\n  @ContentChildren(CarouselItemDirective) carouselItems:\\n    QueryList<CarouselItemDirective>;\\n\\n  private readonly DELTA_DIRECTION_COEFFICIENT = -1;\\n  private readonly MOVE_THRESHOLD = 15;\\n  private moveThreshold = 0;\\n  private goToPrevPage = 0;\\n  private goToNextPage = 0;\\n  public active = 1;\\n\\n  private destroyed$ = new Subject<void>();\\n\\n  constructor(private el: ElementRef) {\\n  }\\n\\n  ngOnInit(): void {\\n    const clientWidth = this.el.nativeElement.firstChild.clientWidth;\\n    this.moveThreshold = (clientWidth * this.MOVE_THRESHOLD) / 100;\\n    this.goToPrevPage = -1 * this.moveThreshold - 1;\\n    this.goToNextPage = this.moveThreshold + 1;\\n  }\\n\\n  public ngAfterContentInit(): void {\\n    const nativeElement = this.el.nativeElement;\\n    const items = this.carouselItems.toArray();\\n\\n    const touchStart$ = merge(\\n      fromEvent(nativeElement, 'touchstart').pipe(\\n        preventEventPropagation,\\n        map((event: any) => event.touches[0])\\n      ),\\n      fromEvent(nativeElement, 'mousedown').pipe(\\n        preventEventPropagation\\n      )\\n    ).pipe(\\n      tap((e: Event) => {\\n        items.forEach(item => {\\n          this.animateCarouselItem(item, null, 0);\\n        });\\n      })\\n    );\\n\\n    const touchMove$ = (startEvent) => merge(\\n      fromEvent(nativeElement, 'touchmove').pipe(\\n        preventEventPropagation,\\n        map((event: any) => event.touches[0])),\\n      fromEvent(nativeElement, 'mousemove').pipe(\\n        preventEventPropagation\\n      )\\n    ).pipe(\\n      observeOn(animationFrameScheduler),\\n      takeUntil(\\n        race(\\n          fromEvent(nativeElement, 'touchend'),\\n          fromEvent(nativeElement, 'mouseup')\\n        )\\n      ),\\n      map((event) => event.pageX),\\n      map((pageX) => Math.round(startEvent.pageX - pageX)),\\n      tap(data => {\\n        items.forEach(item => {\\n          const delta = this.DELTA_DIRECTION_COEFFICIENT *\\n            ((this.active - 1) *\\n              this.el.nativeElement.firstChild.clientWidth) - data;\\n          this.animateCarouselItem(item, delta, null);\\n        });\\n      }),\\n      takeLast(1)\\n    );\\n\\n    const swipe$ = touchStart$.pipe(\\n      switchMap((startEvent: TouchEvent) => touchMove$(startEvent)),\\n    );\\n\\n    const leftArrow$ = fromEvent(document, 'keydown').pipe(\\n      filter((event: KeyboardEvent) => event.code === 'KeyA'),\\n      mapTo(this.goToPrevPage)\\n    );\\n\\n    const rightArrow$ = fromEvent(document, 'keydown').pipe(\\n      filter((event: KeyboardEvent) => event.code === 'KeyD'),\\n      mapTo(this.goToNextPage)\\n    );\\n\\n    const events$ =  merge(swipe$, leftArrow$, rightArrow$).pipe(\\n      share()\\n    );\\n\\n    const timer$ = interval(5000).pipe(\\n        takeUntil(events$),\\n        repeatWhen(source => source),\\n        tap(() => {\\n          if (this.active >= items.length) {\\n            this.active = 0;\\n            items.forEach(item => {\\n              this.animateCarouselItem(item, 0, 300);\\n            });\\n          }\\n        }),\\n        mapTo(this.goToNextPage)\\n      );\\n\\n\\n    merge(events$, timer$).pipe(\\n      tap(val => {\\n        if (val > this.moveThreshold && this.active < items.length) {\\n          this.active++;\\n        } else if (val < -1 * this.moveThreshold && this.active > 1) {\\n          this.active--;\\n        }\\n\\n        items.forEach(item => {\\n          const delta = this.DELTA_DIRECTION_COEFFICIENT *\\n            ((this.active - 1) *\\n              this.el.nativeElement.firstChild.clientWidth);\\n          this.animateCarouselItem(item, delta, 300);\\n        });\\n      }),\\n      takeUntil(this.destroyed$)\\n    ).subscribe();\\n  }\\n\\n  private animateCarouselItem(\\n    item: CarouselItemDirective,\\n    delta?: number,\\n    transitionTime?: number\\n  ): void {\\n    if (!!transitionTime) {\\n      item.setTransition(transitionTime);\\n    }\\n    if (!!delta || delta === 0) {\\n      item.setStyle('transform', `translateX(${delta}px)`);\\n    }\\n  }\\n\\n  public ngOnDestroy() {\\n    this.destroyed$.next();\\n    this.destroyed$.complete();\\n  }\\n}\\n\")), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-ts\",\n    \"metastring\": \"119:122 file=./code/carousel/src/app/carousel/carousel.component.ts title=\\\"Merge and share all event observables\\\"\",\n    \"119:122\": true,\n    \"file\": \"./code/carousel/src/app/carousel/carousel.component.ts\",\n    \"title\": \"\\\"Merge\",\n    \"and\": true,\n    \"share\": true,\n    \"all\": true,\n    \"event\": true,\n    \"observables\\\"\": true\n  }), \"import { fromEvent, Subject, merge, interval, race, animationFrameScheduler } from 'rxjs';\\nimport {\\n  AfterContentInit,\\n  Component,\\n  ContentChildren,\\n  ElementRef,\\n  QueryList,\\n  OnInit,\\n  OnDestroy\\n} from '@angular/core';\\nimport {\\n  map,\\n  takeLast,\\n  takeUntil,\\n  tap,\\n  switchMap,\\n  filter,\\n  mapTo,\\n  share,\\n  repeatWhen,\\n  observeOn\\n} from 'rxjs/operators';\\n\\nimport { CarouselItemDirective } from './carousel-item.directive';\\nimport { preventEventPropagation } from './util';\\n\\n@Component({\\n  selector: 'app-carousel',\\n  templateUrl: './carousel.component.html',\\n  styleUrls: ['./carousel.component.scss']\\n})\\nexport class CarouselComponent implements\\n  OnInit, AfterContentInit, OnDestroy {\\n\\n  @ContentChildren(CarouselItemDirective) carouselItems:\\n    QueryList<CarouselItemDirective>;\\n\\n  private readonly DELTA_DIRECTION_COEFFICIENT = -1;\\n  private readonly MOVE_THRESHOLD = 15;\\n  private moveThreshold = 0;\\n  private goToPrevPage = 0;\\n  private goToNextPage = 0;\\n  public active = 1;\\n\\n  private destroyed$ = new Subject<void>();\\n\\n  constructor(private el: ElementRef) {\\n  }\\n\\n  ngOnInit(): void {\\n    const clientWidth = this.el.nativeElement.firstChild.clientWidth;\\n    this.moveThreshold = (clientWidth * this.MOVE_THRESHOLD) / 100;\\n    this.goToPrevPage = -1 * this.moveThreshold - 1;\\n    this.goToNextPage = this.moveThreshold + 1;\\n  }\\n\\n  public ngAfterContentInit(): void {\\n    const nativeElement = this.el.nativeElement;\\n    const items = this.carouselItems.toArray();\\n\\n    const touchStart$ = merge(\\n      fromEvent(nativeElement, 'touchstart').pipe(\\n        preventEventPropagation,\\n        map((event: any) => event.touches[0])\\n      ),\\n      fromEvent(nativeElement, 'mousedown').pipe(\\n        preventEventPropagation\\n      )\\n    ).pipe(\\n      tap((e: Event) => {\\n        items.forEach(item => {\\n          this.animateCarouselItem(item, null, 0);\\n        });\\n      })\\n    );\\n\\n    const touchMove$ = (startEvent) => merge(\\n      fromEvent(nativeElement, 'touchmove').pipe(\\n        preventEventPropagation,\\n        map((event: any) => event.touches[0])),\\n      fromEvent(nativeElement, 'mousemove').pipe(\\n        preventEventPropagation\\n      )\\n    ).pipe(\\n      observeOn(animationFrameScheduler),\\n      takeUntil(\\n        race(\\n          fromEvent(nativeElement, 'touchend'),\\n          fromEvent(nativeElement, 'mouseup')\\n        )\\n      ),\\n      map((event) => event.pageX),\\n      map((pageX) => Math.round(startEvent.pageX - pageX)),\\n      tap(data => {\\n        items.forEach(item => {\\n          const delta = this.DELTA_DIRECTION_COEFFICIENT *\\n            ((this.active - 1) *\\n              this.el.nativeElement.firstChild.clientWidth) - data;\\n          this.animateCarouselItem(item, delta, null);\\n        });\\n      }),\\n      takeLast(1)\\n    );\\n\\n    const swipe$ = touchStart$.pipe(\\n      switchMap((startEvent: TouchEvent) => touchMove$(startEvent)),\\n    );\\n\\n    const leftArrow$ = fromEvent(document, 'keydown').pipe(\\n      filter((event: KeyboardEvent) => event.code === 'KeyA'),\\n      mapTo(this.goToPrevPage)\\n    );\\n\\n    const rightArrow$ = fromEvent(document, 'keydown').pipe(\\n      filter((event: KeyboardEvent) => event.code === 'KeyD'),\\n      mapTo(this.goToNextPage)\\n    );\\n\\n    const events$ =  merge(swipe$, leftArrow$, rightArrow$).pipe(\\n      share()\\n    );\\n\\n    const timer$ = interval(5000).pipe(\\n        takeUntil(events$),\\n        repeatWhen(source => source),\\n        tap(() => {\\n          if (this.active >= items.length) {\\n            this.active = 0;\\n            items.forEach(item => {\\n              this.animateCarouselItem(item, 0, 300);\\n            });\\n          }\\n        }),\\n        mapTo(this.goToNextPage)\\n      );\\n\\n\\n    merge(events$, timer$).pipe(\\n      tap(val => {\\n        if (val > this.moveThreshold && this.active < items.length) {\\n          this.active++;\\n        } else if (val < -1 * this.moveThreshold && this.active > 1) {\\n          this.active--;\\n        }\\n\\n        items.forEach(item => {\\n          const delta = this.DELTA_DIRECTION_COEFFICIENT *\\n            ((this.active - 1) *\\n              this.el.nativeElement.firstChild.clientWidth);\\n          this.animateCarouselItem(item, delta, 300);\\n        });\\n      }),\\n      takeUntil(this.destroyed$)\\n    ).subscribe();\\n  }\\n\\n  private animateCarouselItem(\\n    item: CarouselItemDirective,\\n    delta?: number,\\n    transitionTime?: number\\n  ): void {\\n    if (!!transitionTime) {\\n      item.setTransition(transitionTime);\\n    }\\n    if (!!delta || delta === 0) {\\n      item.setStyle('transform', `translateX(${delta}px)`);\\n    }\\n  }\\n\\n  public ngOnDestroy() {\\n    this.destroyed$.next();\\n    this.destroyed$.complete();\\n  }\\n}\\n\")), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"138\": true,\n    \"className\": \"language-ts\",\n    \"metastring\": \"138 file=./code/carousel/src/app/carousel/carousel.component.ts title=\\\"prepare merge of event and timer observable\\\"\",\n    \"file\": \"./code/carousel/src/app/carousel/carousel.component.ts\",\n    \"title\": \"\\\"prepare\",\n    \"merge\": true,\n    \"of\": true,\n    \"event\": true,\n    \"and\": true,\n    \"timer\": true,\n    \"observable\\\"\": true\n  }), \"import { fromEvent, Subject, merge, interval, race, animationFrameScheduler } from 'rxjs';\\nimport {\\n  AfterContentInit,\\n  Component,\\n  ContentChildren,\\n  ElementRef,\\n  QueryList,\\n  OnInit,\\n  OnDestroy\\n} from '@angular/core';\\nimport {\\n  map,\\n  takeLast,\\n  takeUntil,\\n  tap,\\n  switchMap,\\n  filter,\\n  mapTo,\\n  share,\\n  repeatWhen,\\n  observeOn\\n} from 'rxjs/operators';\\n\\nimport { CarouselItemDirective } from './carousel-item.directive';\\nimport { preventEventPropagation } from './util';\\n\\n@Component({\\n  selector: 'app-carousel',\\n  templateUrl: './carousel.component.html',\\n  styleUrls: ['./carousel.component.scss']\\n})\\nexport class CarouselComponent implements\\n  OnInit, AfterContentInit, OnDestroy {\\n\\n  @ContentChildren(CarouselItemDirective) carouselItems:\\n    QueryList<CarouselItemDirective>;\\n\\n  private readonly DELTA_DIRECTION_COEFFICIENT = -1;\\n  private readonly MOVE_THRESHOLD = 15;\\n  private moveThreshold = 0;\\n  private goToPrevPage = 0;\\n  private goToNextPage = 0;\\n  public active = 1;\\n\\n  private destroyed$ = new Subject<void>();\\n\\n  constructor(private el: ElementRef) {\\n  }\\n\\n  ngOnInit(): void {\\n    const clientWidth = this.el.nativeElement.firstChild.clientWidth;\\n    this.moveThreshold = (clientWidth * this.MOVE_THRESHOLD) / 100;\\n    this.goToPrevPage = -1 * this.moveThreshold - 1;\\n    this.goToNextPage = this.moveThreshold + 1;\\n  }\\n\\n  public ngAfterContentInit(): void {\\n    const nativeElement = this.el.nativeElement;\\n    const items = this.carouselItems.toArray();\\n\\n    const touchStart$ = merge(\\n      fromEvent(nativeElement, 'touchstart').pipe(\\n        preventEventPropagation,\\n        map((event: any) => event.touches[0])\\n      ),\\n      fromEvent(nativeElement, 'mousedown').pipe(\\n        preventEventPropagation\\n      )\\n    ).pipe(\\n      tap((e: Event) => {\\n        items.forEach(item => {\\n          this.animateCarouselItem(item, null, 0);\\n        });\\n      })\\n    );\\n\\n    const touchMove$ = (startEvent) => merge(\\n      fromEvent(nativeElement, 'touchmove').pipe(\\n        preventEventPropagation,\\n        map((event: any) => event.touches[0])),\\n      fromEvent(nativeElement, 'mousemove').pipe(\\n        preventEventPropagation\\n      )\\n    ).pipe(\\n      observeOn(animationFrameScheduler),\\n      takeUntil(\\n        race(\\n          fromEvent(nativeElement, 'touchend'),\\n          fromEvent(nativeElement, 'mouseup')\\n        )\\n      ),\\n      map((event) => event.pageX),\\n      map((pageX) => Math.round(startEvent.pageX - pageX)),\\n      tap(data => {\\n        items.forEach(item => {\\n          const delta = this.DELTA_DIRECTION_COEFFICIENT *\\n            ((this.active - 1) *\\n              this.el.nativeElement.firstChild.clientWidth) - data;\\n          this.animateCarouselItem(item, delta, null);\\n        });\\n      }),\\n      takeLast(1)\\n    );\\n\\n    const swipe$ = touchStart$.pipe(\\n      switchMap((startEvent: TouchEvent) => touchMove$(startEvent)),\\n    );\\n\\n    const leftArrow$ = fromEvent(document, 'keydown').pipe(\\n      filter((event: KeyboardEvent) => event.code === 'KeyA'),\\n      mapTo(this.goToPrevPage)\\n    );\\n\\n    const rightArrow$ = fromEvent(document, 'keydown').pipe(\\n      filter((event: KeyboardEvent) => event.code === 'KeyD'),\\n      mapTo(this.goToNextPage)\\n    );\\n\\n    const events$ =  merge(swipe$, leftArrow$, rightArrow$).pipe(\\n      share()\\n    );\\n\\n    const timer$ = interval(5000).pipe(\\n        takeUntil(events$),\\n        repeatWhen(source => source),\\n        tap(() => {\\n          if (this.active >= items.length) {\\n            this.active = 0;\\n            items.forEach(item => {\\n              this.animateCarouselItem(item, 0, 300);\\n            });\\n          }\\n        }),\\n        mapTo(this.goToNextPage)\\n      );\\n\\n\\n    merge(events$, timer$).pipe(\\n      tap(val => {\\n        if (val > this.moveThreshold && this.active < items.length) {\\n          this.active++;\\n        } else if (val < -1 * this.moveThreshold && this.active > 1) {\\n          this.active--;\\n        }\\n\\n        items.forEach(item => {\\n          const delta = this.DELTA_DIRECTION_COEFFICIENT *\\n            ((this.active - 1) *\\n              this.el.nativeElement.firstChild.clientWidth);\\n          this.animateCarouselItem(item, delta, 300);\\n        });\\n      }),\\n      takeUntil(this.destroyed$)\\n    ).subscribe();\\n  }\\n\\n  private animateCarouselItem(\\n    item: CarouselItemDirective,\\n    delta?: number,\\n    transitionTime?: number\\n  ): void {\\n    if (!!transitionTime) {\\n      item.setTransition(transitionTime);\\n    }\\n    if (!!delta || delta === 0) {\\n      item.setStyle('transform', `translateX(${delta}px)`);\\n    }\\n  }\\n\\n  public ngOnDestroy() {\\n    this.destroyed$.next();\\n    this.destroyed$.complete();\\n  }\\n}\\n\")), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-ts\",\n    \"metastring\": \"139:152 file=./code/carousel/src/app/carousel/carousel.component.ts title=\\\"Animate to next slide\\\"\",\n    \"139:152\": true,\n    \"file\": \"./code/carousel/src/app/carousel/carousel.component.ts\",\n    \"title\": \"\\\"Animate\",\n    \"to\": true,\n    \"next\": true,\n    \"slide\\\"\": true\n  }), \"import { fromEvent, Subject, merge, interval, race, animationFrameScheduler } from 'rxjs';\\nimport {\\n  AfterContentInit,\\n  Component,\\n  ContentChildren,\\n  ElementRef,\\n  QueryList,\\n  OnInit,\\n  OnDestroy\\n} from '@angular/core';\\nimport {\\n  map,\\n  takeLast,\\n  takeUntil,\\n  tap,\\n  switchMap,\\n  filter,\\n  mapTo,\\n  share,\\n  repeatWhen,\\n  observeOn\\n} from 'rxjs/operators';\\n\\nimport { CarouselItemDirective } from './carousel-item.directive';\\nimport { preventEventPropagation } from './util';\\n\\n@Component({\\n  selector: 'app-carousel',\\n  templateUrl: './carousel.component.html',\\n  styleUrls: ['./carousel.component.scss']\\n})\\nexport class CarouselComponent implements\\n  OnInit, AfterContentInit, OnDestroy {\\n\\n  @ContentChildren(CarouselItemDirective) carouselItems:\\n    QueryList<CarouselItemDirective>;\\n\\n  private readonly DELTA_DIRECTION_COEFFICIENT = -1;\\n  private readonly MOVE_THRESHOLD = 15;\\n  private moveThreshold = 0;\\n  private goToPrevPage = 0;\\n  private goToNextPage = 0;\\n  public active = 1;\\n\\n  private destroyed$ = new Subject<void>();\\n\\n  constructor(private el: ElementRef) {\\n  }\\n\\n  ngOnInit(): void {\\n    const clientWidth = this.el.nativeElement.firstChild.clientWidth;\\n    this.moveThreshold = (clientWidth * this.MOVE_THRESHOLD) / 100;\\n    this.goToPrevPage = -1 * this.moveThreshold - 1;\\n    this.goToNextPage = this.moveThreshold + 1;\\n  }\\n\\n  public ngAfterContentInit(): void {\\n    const nativeElement = this.el.nativeElement;\\n    const items = this.carouselItems.toArray();\\n\\n    const touchStart$ = merge(\\n      fromEvent(nativeElement, 'touchstart').pipe(\\n        preventEventPropagation,\\n        map((event: any) => event.touches[0])\\n      ),\\n      fromEvent(nativeElement, 'mousedown').pipe(\\n        preventEventPropagation\\n      )\\n    ).pipe(\\n      tap((e: Event) => {\\n        items.forEach(item => {\\n          this.animateCarouselItem(item, null, 0);\\n        });\\n      })\\n    );\\n\\n    const touchMove$ = (startEvent) => merge(\\n      fromEvent(nativeElement, 'touchmove').pipe(\\n        preventEventPropagation,\\n        map((event: any) => event.touches[0])),\\n      fromEvent(nativeElement, 'mousemove').pipe(\\n        preventEventPropagation\\n      )\\n    ).pipe(\\n      observeOn(animationFrameScheduler),\\n      takeUntil(\\n        race(\\n          fromEvent(nativeElement, 'touchend'),\\n          fromEvent(nativeElement, 'mouseup')\\n        )\\n      ),\\n      map((event) => event.pageX),\\n      map((pageX) => Math.round(startEvent.pageX - pageX)),\\n      tap(data => {\\n        items.forEach(item => {\\n          const delta = this.DELTA_DIRECTION_COEFFICIENT *\\n            ((this.active - 1) *\\n              this.el.nativeElement.firstChild.clientWidth) - data;\\n          this.animateCarouselItem(item, delta, null);\\n        });\\n      }),\\n      takeLast(1)\\n    );\\n\\n    const swipe$ = touchStart$.pipe(\\n      switchMap((startEvent: TouchEvent) => touchMove$(startEvent)),\\n    );\\n\\n    const leftArrow$ = fromEvent(document, 'keydown').pipe(\\n      filter((event: KeyboardEvent) => event.code === 'KeyA'),\\n      mapTo(this.goToPrevPage)\\n    );\\n\\n    const rightArrow$ = fromEvent(document, 'keydown').pipe(\\n      filter((event: KeyboardEvent) => event.code === 'KeyD'),\\n      mapTo(this.goToNextPage)\\n    );\\n\\n    const events$ =  merge(swipe$, leftArrow$, rightArrow$).pipe(\\n      share()\\n    );\\n\\n    const timer$ = interval(5000).pipe(\\n        takeUntil(events$),\\n        repeatWhen(source => source),\\n        tap(() => {\\n          if (this.active >= items.length) {\\n            this.active = 0;\\n            items.forEach(item => {\\n              this.animateCarouselItem(item, 0, 300);\\n            });\\n          }\\n        }),\\n        mapTo(this.goToNextPage)\\n      );\\n\\n\\n    merge(events$, timer$).pipe(\\n      tap(val => {\\n        if (val > this.moveThreshold && this.active < items.length) {\\n          this.active++;\\n        } else if (val < -1 * this.moveThreshold && this.active > 1) {\\n          this.active--;\\n        }\\n\\n        items.forEach(item => {\\n          const delta = this.DELTA_DIRECTION_COEFFICIENT *\\n            ((this.active - 1) *\\n              this.el.nativeElement.firstChild.clientWidth);\\n          this.animateCarouselItem(item, delta, 300);\\n        });\\n      }),\\n      takeUntil(this.destroyed$)\\n    ).subscribe();\\n  }\\n\\n  private animateCarouselItem(\\n    item: CarouselItemDirective,\\n    delta?: number,\\n    transitionTime?: number\\n  ): void {\\n    if (!!transitionTime) {\\n      item.setTransition(transitionTime);\\n    }\\n    if (!!delta || delta === 0) {\\n      item.setStyle('transform', `translateX(${delta}px)`);\\n    }\\n  }\\n\\n  public ngOnDestroy() {\\n    this.destroyed$.next();\\n    this.destroyed$.complete();\\n  }\\n}\\n\")), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"153\": true,\n    \"className\": \"language-ts\",\n    \"metastring\": \"153 file=./code/carousel/src/app/carousel/carousel.component.ts title=\\\"Don't forget to unsubscribe\\\"\",\n    \"file\": \"./code/carousel/src/app/carousel/carousel.component.ts\",\n    \"title\": \"\\\"Don't\",\n    \"forget\": true,\n    \"to\": true,\n    \"unsubscribe\\\"\": true\n  }), \"import { fromEvent, Subject, merge, interval, race, animationFrameScheduler } from 'rxjs';\\nimport {\\n  AfterContentInit,\\n  Component,\\n  ContentChildren,\\n  ElementRef,\\n  QueryList,\\n  OnInit,\\n  OnDestroy\\n} from '@angular/core';\\nimport {\\n  map,\\n  takeLast,\\n  takeUntil,\\n  tap,\\n  switchMap,\\n  filter,\\n  mapTo,\\n  share,\\n  repeatWhen,\\n  observeOn\\n} from 'rxjs/operators';\\n\\nimport { CarouselItemDirective } from './carousel-item.directive';\\nimport { preventEventPropagation } from './util';\\n\\n@Component({\\n  selector: 'app-carousel',\\n  templateUrl: './carousel.component.html',\\n  styleUrls: ['./carousel.component.scss']\\n})\\nexport class CarouselComponent implements\\n  OnInit, AfterContentInit, OnDestroy {\\n\\n  @ContentChildren(CarouselItemDirective) carouselItems:\\n    QueryList<CarouselItemDirective>;\\n\\n  private readonly DELTA_DIRECTION_COEFFICIENT = -1;\\n  private readonly MOVE_THRESHOLD = 15;\\n  private moveThreshold = 0;\\n  private goToPrevPage = 0;\\n  private goToNextPage = 0;\\n  public active = 1;\\n\\n  private destroyed$ = new Subject<void>();\\n\\n  constructor(private el: ElementRef) {\\n  }\\n\\n  ngOnInit(): void {\\n    const clientWidth = this.el.nativeElement.firstChild.clientWidth;\\n    this.moveThreshold = (clientWidth * this.MOVE_THRESHOLD) / 100;\\n    this.goToPrevPage = -1 * this.moveThreshold - 1;\\n    this.goToNextPage = this.moveThreshold + 1;\\n  }\\n\\n  public ngAfterContentInit(): void {\\n    const nativeElement = this.el.nativeElement;\\n    const items = this.carouselItems.toArray();\\n\\n    const touchStart$ = merge(\\n      fromEvent(nativeElement, 'touchstart').pipe(\\n        preventEventPropagation,\\n        map((event: any) => event.touches[0])\\n      ),\\n      fromEvent(nativeElement, 'mousedown').pipe(\\n        preventEventPropagation\\n      )\\n    ).pipe(\\n      tap((e: Event) => {\\n        items.forEach(item => {\\n          this.animateCarouselItem(item, null, 0);\\n        });\\n      })\\n    );\\n\\n    const touchMove$ = (startEvent) => merge(\\n      fromEvent(nativeElement, 'touchmove').pipe(\\n        preventEventPropagation,\\n        map((event: any) => event.touches[0])),\\n      fromEvent(nativeElement, 'mousemove').pipe(\\n        preventEventPropagation\\n      )\\n    ).pipe(\\n      observeOn(animationFrameScheduler),\\n      takeUntil(\\n        race(\\n          fromEvent(nativeElement, 'touchend'),\\n          fromEvent(nativeElement, 'mouseup')\\n        )\\n      ),\\n      map((event) => event.pageX),\\n      map((pageX) => Math.round(startEvent.pageX - pageX)),\\n      tap(data => {\\n        items.forEach(item => {\\n          const delta = this.DELTA_DIRECTION_COEFFICIENT *\\n            ((this.active - 1) *\\n              this.el.nativeElement.firstChild.clientWidth) - data;\\n          this.animateCarouselItem(item, delta, null);\\n        });\\n      }),\\n      takeLast(1)\\n    );\\n\\n    const swipe$ = touchStart$.pipe(\\n      switchMap((startEvent: TouchEvent) => touchMove$(startEvent)),\\n    );\\n\\n    const leftArrow$ = fromEvent(document, 'keydown').pipe(\\n      filter((event: KeyboardEvent) => event.code === 'KeyA'),\\n      mapTo(this.goToPrevPage)\\n    );\\n\\n    const rightArrow$ = fromEvent(document, 'keydown').pipe(\\n      filter((event: KeyboardEvent) => event.code === 'KeyD'),\\n      mapTo(this.goToNextPage)\\n    );\\n\\n    const events$ =  merge(swipe$, leftArrow$, rightArrow$).pipe(\\n      share()\\n    );\\n\\n    const timer$ = interval(5000).pipe(\\n        takeUntil(events$),\\n        repeatWhen(source => source),\\n        tap(() => {\\n          if (this.active >= items.length) {\\n            this.active = 0;\\n            items.forEach(item => {\\n              this.animateCarouselItem(item, 0, 300);\\n            });\\n          }\\n        }),\\n        mapTo(this.goToNextPage)\\n      );\\n\\n\\n    merge(events$, timer$).pipe(\\n      tap(val => {\\n        if (val > this.moveThreshold && this.active < items.length) {\\n          this.active++;\\n        } else if (val < -1 * this.moveThreshold && this.active > 1) {\\n          this.active--;\\n        }\\n\\n        items.forEach(item => {\\n          const delta = this.DELTA_DIRECTION_COEFFICIENT *\\n            ((this.active - 1) *\\n              this.el.nativeElement.firstChild.clientWidth);\\n          this.animateCarouselItem(item, delta, 300);\\n        });\\n      }),\\n      takeUntil(this.destroyed$)\\n    ).subscribe();\\n  }\\n\\n  private animateCarouselItem(\\n    item: CarouselItemDirective,\\n    delta?: number,\\n    transitionTime?: number\\n  ): void {\\n    if (!!transitionTime) {\\n      item.setTransition(transitionTime);\\n    }\\n    if (!!delta || delta === 0) {\\n      item.setStyle('transform', `translateX(${delta}px)`);\\n    }\\n  }\\n\\n  public ngOnDestroy() {\\n    this.destroyed$.next();\\n    this.destroyed$.complete();\\n  }\\n}\\n\")), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"154\": true,\n    \"className\": \"language-ts\",\n    \"metastring\": \"154 file=./code/carousel/src/app/carousel/carousel.component.ts title=\\\"Don't forget to subscribe!\\\"\",\n    \"file\": \"./code/carousel/src/app/carousel/carousel.component.ts\",\n    \"title\": \"\\\"Don't\",\n    \"forget\": true,\n    \"to\": true,\n    \"subscribe!\\\"\": true\n  }), \"import { fromEvent, Subject, merge, interval, race, animationFrameScheduler } from 'rxjs';\\nimport {\\n  AfterContentInit,\\n  Component,\\n  ContentChildren,\\n  ElementRef,\\n  QueryList,\\n  OnInit,\\n  OnDestroy\\n} from '@angular/core';\\nimport {\\n  map,\\n  takeLast,\\n  takeUntil,\\n  tap,\\n  switchMap,\\n  filter,\\n  mapTo,\\n  share,\\n  repeatWhen,\\n  observeOn\\n} from 'rxjs/operators';\\n\\nimport { CarouselItemDirective } from './carousel-item.directive';\\nimport { preventEventPropagation } from './util';\\n\\n@Component({\\n  selector: 'app-carousel',\\n  templateUrl: './carousel.component.html',\\n  styleUrls: ['./carousel.component.scss']\\n})\\nexport class CarouselComponent implements\\n  OnInit, AfterContentInit, OnDestroy {\\n\\n  @ContentChildren(CarouselItemDirective) carouselItems:\\n    QueryList<CarouselItemDirective>;\\n\\n  private readonly DELTA_DIRECTION_COEFFICIENT = -1;\\n  private readonly MOVE_THRESHOLD = 15;\\n  private moveThreshold = 0;\\n  private goToPrevPage = 0;\\n  private goToNextPage = 0;\\n  public active = 1;\\n\\n  private destroyed$ = new Subject<void>();\\n\\n  constructor(private el: ElementRef) {\\n  }\\n\\n  ngOnInit(): void {\\n    const clientWidth = this.el.nativeElement.firstChild.clientWidth;\\n    this.moveThreshold = (clientWidth * this.MOVE_THRESHOLD) / 100;\\n    this.goToPrevPage = -1 * this.moveThreshold - 1;\\n    this.goToNextPage = this.moveThreshold + 1;\\n  }\\n\\n  public ngAfterContentInit(): void {\\n    const nativeElement = this.el.nativeElement;\\n    const items = this.carouselItems.toArray();\\n\\n    const touchStart$ = merge(\\n      fromEvent(nativeElement, 'touchstart').pipe(\\n        preventEventPropagation,\\n        map((event: any) => event.touches[0])\\n      ),\\n      fromEvent(nativeElement, 'mousedown').pipe(\\n        preventEventPropagation\\n      )\\n    ).pipe(\\n      tap((e: Event) => {\\n        items.forEach(item => {\\n          this.animateCarouselItem(item, null, 0);\\n        });\\n      })\\n    );\\n\\n    const touchMove$ = (startEvent) => merge(\\n      fromEvent(nativeElement, 'touchmove').pipe(\\n        preventEventPropagation,\\n        map((event: any) => event.touches[0])),\\n      fromEvent(nativeElement, 'mousemove').pipe(\\n        preventEventPropagation\\n      )\\n    ).pipe(\\n      observeOn(animationFrameScheduler),\\n      takeUntil(\\n        race(\\n          fromEvent(nativeElement, 'touchend'),\\n          fromEvent(nativeElement, 'mouseup')\\n        )\\n      ),\\n      map((event) => event.pageX),\\n      map((pageX) => Math.round(startEvent.pageX - pageX)),\\n      tap(data => {\\n        items.forEach(item => {\\n          const delta = this.DELTA_DIRECTION_COEFFICIENT *\\n            ((this.active - 1) *\\n              this.el.nativeElement.firstChild.clientWidth) - data;\\n          this.animateCarouselItem(item, delta, null);\\n        });\\n      }),\\n      takeLast(1)\\n    );\\n\\n    const swipe$ = touchStart$.pipe(\\n      switchMap((startEvent: TouchEvent) => touchMove$(startEvent)),\\n    );\\n\\n    const leftArrow$ = fromEvent(document, 'keydown').pipe(\\n      filter((event: KeyboardEvent) => event.code === 'KeyA'),\\n      mapTo(this.goToPrevPage)\\n    );\\n\\n    const rightArrow$ = fromEvent(document, 'keydown').pipe(\\n      filter((event: KeyboardEvent) => event.code === 'KeyD'),\\n      mapTo(this.goToNextPage)\\n    );\\n\\n    const events$ =  merge(swipe$, leftArrow$, rightArrow$).pipe(\\n      share()\\n    );\\n\\n    const timer$ = interval(5000).pipe(\\n        takeUntil(events$),\\n        repeatWhen(source => source),\\n        tap(() => {\\n          if (this.active >= items.length) {\\n            this.active = 0;\\n            items.forEach(item => {\\n              this.animateCarouselItem(item, 0, 300);\\n            });\\n          }\\n        }),\\n        mapTo(this.goToNextPage)\\n      );\\n\\n\\n    merge(events$, timer$).pipe(\\n      tap(val => {\\n        if (val > this.moveThreshold && this.active < items.length) {\\n          this.active++;\\n        } else if (val < -1 * this.moveThreshold && this.active > 1) {\\n          this.active--;\\n        }\\n\\n        items.forEach(item => {\\n          const delta = this.DELTA_DIRECTION_COEFFICIENT *\\n            ((this.active - 1) *\\n              this.el.nativeElement.firstChild.clientWidth);\\n          this.animateCarouselItem(item, delta, 300);\\n        });\\n      }),\\n      takeUntil(this.destroyed$)\\n    ).subscribe();\\n  }\\n\\n  private animateCarouselItem(\\n    item: CarouselItemDirective,\\n    delta?: number,\\n    transitionTime?: number\\n  ): void {\\n    if (!!transitionTime) {\\n      item.setTransition(transitionTime);\\n    }\\n    if (!!delta || delta === 0) {\\n      item.setStyle('transform', `translateX(${delta}px)`);\\n    }\\n  }\\n\\n  public ngOnDestroy() {\\n    this.destroyed$.next();\\n    this.destroyed$.complete();\\n  }\\n}\\n\")))), mdx(\"hr\", null), mdx(Styles, {\n    mdxType: \"Styles\"\n  }), mdx(\"main\", null, mdx(CodeSurfer, {\n    theme: vsDarkReal,\n    mdxType: \"CodeSurfer\"\n  }, mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-ts\",\n    \"metastring\": \"109:112 file=./code/carousel/src/app/carousel/carousel.component.ts title=\\\"Add Keyboard Navigation for left arrow\\\"\",\n    \"109:112\": true,\n    \"file\": \"./code/carousel/src/app/carousel/carousel.component.ts\",\n    \"title\": \"\\\"Add\",\n    \"Keyboard\": true,\n    \"Navigation\": true,\n    \"for\": true,\n    \"left\": true,\n    \"arrow\\\"\": true\n  }), \"import { fromEvent, Subject, merge, interval, race, animationFrameScheduler } from 'rxjs';\\nimport {\\n  AfterContentInit,\\n  Component,\\n  ContentChildren,\\n  ElementRef,\\n  QueryList,\\n  OnInit,\\n  OnDestroy\\n} from '@angular/core';\\nimport {\\n  map,\\n  takeLast,\\n  takeUntil,\\n  tap,\\n  switchMap,\\n  filter,\\n  mapTo,\\n  share,\\n  repeatWhen,\\n  observeOn\\n} from 'rxjs/operators';\\n\\nimport { CarouselItemDirective } from './carousel-item.directive';\\nimport { preventEventPropagation } from './util';\\n\\n@Component({\\n  selector: 'app-carousel',\\n  templateUrl: './carousel.component.html',\\n  styleUrls: ['./carousel.component.scss']\\n})\\nexport class CarouselComponent implements\\n  OnInit, AfterContentInit, OnDestroy {\\n\\n  @ContentChildren(CarouselItemDirective) carouselItems:\\n    QueryList<CarouselItemDirective>;\\n\\n  private readonly DELTA_DIRECTION_COEFFICIENT = -1;\\n  private readonly MOVE_THRESHOLD = 15;\\n  private moveThreshold = 0;\\n  private goToPrevPage = 0;\\n  private goToNextPage = 0;\\n  public active = 1;\\n\\n  private destroyed$ = new Subject<void>();\\n\\n  constructor(private el: ElementRef) {\\n  }\\n\\n  ngOnInit(): void {\\n    const clientWidth = this.el.nativeElement.firstChild.clientWidth;\\n    this.moveThreshold = (clientWidth * this.MOVE_THRESHOLD) / 100;\\n    this.goToPrevPage = -1 * this.moveThreshold - 1;\\n    this.goToNextPage = this.moveThreshold + 1;\\n  }\\n\\n  public ngAfterContentInit(): void {\\n    const nativeElement = this.el.nativeElement;\\n    const items = this.carouselItems.toArray();\\n\\n    const touchStart$ = merge(\\n      fromEvent(nativeElement, 'touchstart').pipe(\\n        preventEventPropagation,\\n        map((event: any) => event.touches[0])\\n      ),\\n      fromEvent(nativeElement, 'mousedown').pipe(\\n        preventEventPropagation\\n      )\\n    ).pipe(\\n      tap((e: Event) => {\\n        items.forEach(item => {\\n          this.animateCarouselItem(item, null, 0);\\n        });\\n      })\\n    );\\n\\n    const touchMove$ = (startEvent) => merge(\\n      fromEvent(nativeElement, 'touchmove').pipe(\\n        preventEventPropagation,\\n        map((event: any) => event.touches[0])),\\n      fromEvent(nativeElement, 'mousemove').pipe(\\n        preventEventPropagation\\n      )\\n    ).pipe(\\n      observeOn(animationFrameScheduler),\\n      takeUntil(\\n        race(\\n          fromEvent(nativeElement, 'touchend'),\\n          fromEvent(nativeElement, 'mouseup')\\n        )\\n      ),\\n      map((event) => event.pageX),\\n      map((pageX) => Math.round(startEvent.pageX - pageX)),\\n      tap(data => {\\n        items.forEach(item => {\\n          const delta = this.DELTA_DIRECTION_COEFFICIENT *\\n            ((this.active - 1) *\\n              this.el.nativeElement.firstChild.clientWidth) - data;\\n          this.animateCarouselItem(item, delta, null);\\n        });\\n      }),\\n      takeLast(1)\\n    );\\n\\n    const swipe$ = touchStart$.pipe(\\n      switchMap((startEvent: TouchEvent) => touchMove$(startEvent)),\\n    );\\n\\n    const leftArrow$ = fromEvent(document, 'keydown').pipe(\\n      filter((event: KeyboardEvent) => event.code === 'KeyA'),\\n      mapTo(this.goToPrevPage)\\n    );\\n\\n    const rightArrow$ = fromEvent(document, 'keydown').pipe(\\n      filter((event: KeyboardEvent) => event.code === 'KeyD'),\\n      mapTo(this.goToNextPage)\\n    );\\n\\n    const events$ =  merge(swipe$, leftArrow$, rightArrow$).pipe(\\n      share()\\n    );\\n\\n    const timer$ = interval(5000).pipe(\\n        takeUntil(events$),\\n        repeatWhen(source => source),\\n        tap(() => {\\n          if (this.active >= items.length) {\\n            this.active = 0;\\n            items.forEach(item => {\\n              this.animateCarouselItem(item, 0, 300);\\n            });\\n          }\\n        }),\\n        mapTo(this.goToNextPage)\\n      );\\n\\n\\n    merge(events$, timer$).pipe(\\n      tap(val => {\\n        if (val > this.moveThreshold && this.active < items.length) {\\n          this.active++;\\n        } else if (val < -1 * this.moveThreshold && this.active > 1) {\\n          this.active--;\\n        }\\n\\n        items.forEach(item => {\\n          const delta = this.DELTA_DIRECTION_COEFFICIENT *\\n            ((this.active - 1) *\\n              this.el.nativeElement.firstChild.clientWidth);\\n          this.animateCarouselItem(item, delta, 300);\\n        });\\n      }),\\n      takeUntil(this.destroyed$)\\n    ).subscribe();\\n  }\\n\\n  private animateCarouselItem(\\n    item: CarouselItemDirective,\\n    delta?: number,\\n    transitionTime?: number\\n  ): void {\\n    if (!!transitionTime) {\\n      item.setTransition(transitionTime);\\n    }\\n    if (!!delta || delta === 0) {\\n      item.setStyle('transform', `translateX(${delta}px)`);\\n    }\\n  }\\n\\n  public ngOnDestroy() {\\n    this.destroyed$.next();\\n    this.destroyed$.complete();\\n  }\\n}\\n\")), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-ts\",\n    \"metastring\": \"114:118 file=./code/carousel/src/app/carousel/carousel.component.ts title=\\\"Add Keyboard Navigation for right arrow\\\"\",\n    \"114:118\": true,\n    \"file\": \"./code/carousel/src/app/carousel/carousel.component.ts\",\n    \"title\": \"\\\"Add\",\n    \"Keyboard\": true,\n    \"Navigation\": true,\n    \"for\": true,\n    \"right\": true,\n    \"arrow\\\"\": true\n  }), \"import { fromEvent, Subject, merge, interval, race, animationFrameScheduler } from 'rxjs';\\nimport {\\n  AfterContentInit,\\n  Component,\\n  ContentChildren,\\n  ElementRef,\\n  QueryList,\\n  OnInit,\\n  OnDestroy\\n} from '@angular/core';\\nimport {\\n  map,\\n  takeLast,\\n  takeUntil,\\n  tap,\\n  switchMap,\\n  filter,\\n  mapTo,\\n  share,\\n  repeatWhen,\\n  observeOn\\n} from 'rxjs/operators';\\n\\nimport { CarouselItemDirective } from './carousel-item.directive';\\nimport { preventEventPropagation } from './util';\\n\\n@Component({\\n  selector: 'app-carousel',\\n  templateUrl: './carousel.component.html',\\n  styleUrls: ['./carousel.component.scss']\\n})\\nexport class CarouselComponent implements\\n  OnInit, AfterContentInit, OnDestroy {\\n\\n  @ContentChildren(CarouselItemDirective) carouselItems:\\n    QueryList<CarouselItemDirective>;\\n\\n  private readonly DELTA_DIRECTION_COEFFICIENT = -1;\\n  private readonly MOVE_THRESHOLD = 15;\\n  private moveThreshold = 0;\\n  private goToPrevPage = 0;\\n  private goToNextPage = 0;\\n  public active = 1;\\n\\n  private destroyed$ = new Subject<void>();\\n\\n  constructor(private el: ElementRef) {\\n  }\\n\\n  ngOnInit(): void {\\n    const clientWidth = this.el.nativeElement.firstChild.clientWidth;\\n    this.moveThreshold = (clientWidth * this.MOVE_THRESHOLD) / 100;\\n    this.goToPrevPage = -1 * this.moveThreshold - 1;\\n    this.goToNextPage = this.moveThreshold + 1;\\n  }\\n\\n  public ngAfterContentInit(): void {\\n    const nativeElement = this.el.nativeElement;\\n    const items = this.carouselItems.toArray();\\n\\n    const touchStart$ = merge(\\n      fromEvent(nativeElement, 'touchstart').pipe(\\n        preventEventPropagation,\\n        map((event: any) => event.touches[0])\\n      ),\\n      fromEvent(nativeElement, 'mousedown').pipe(\\n        preventEventPropagation\\n      )\\n    ).pipe(\\n      tap((e: Event) => {\\n        items.forEach(item => {\\n          this.animateCarouselItem(item, null, 0);\\n        });\\n      })\\n    );\\n\\n    const touchMove$ = (startEvent) => merge(\\n      fromEvent(nativeElement, 'touchmove').pipe(\\n        preventEventPropagation,\\n        map((event: any) => event.touches[0])),\\n      fromEvent(nativeElement, 'mousemove').pipe(\\n        preventEventPropagation\\n      )\\n    ).pipe(\\n      observeOn(animationFrameScheduler),\\n      takeUntil(\\n        race(\\n          fromEvent(nativeElement, 'touchend'),\\n          fromEvent(nativeElement, 'mouseup')\\n        )\\n      ),\\n      map((event) => event.pageX),\\n      map((pageX) => Math.round(startEvent.pageX - pageX)),\\n      tap(data => {\\n        items.forEach(item => {\\n          const delta = this.DELTA_DIRECTION_COEFFICIENT *\\n            ((this.active - 1) *\\n              this.el.nativeElement.firstChild.clientWidth) - data;\\n          this.animateCarouselItem(item, delta, null);\\n        });\\n      }),\\n      takeLast(1)\\n    );\\n\\n    const swipe$ = touchStart$.pipe(\\n      switchMap((startEvent: TouchEvent) => touchMove$(startEvent)),\\n    );\\n\\n    const leftArrow$ = fromEvent(document, 'keydown').pipe(\\n      filter((event: KeyboardEvent) => event.code === 'KeyA'),\\n      mapTo(this.goToPrevPage)\\n    );\\n\\n    const rightArrow$ = fromEvent(document, 'keydown').pipe(\\n      filter((event: KeyboardEvent) => event.code === 'KeyD'),\\n      mapTo(this.goToNextPage)\\n    );\\n\\n    const events$ =  merge(swipe$, leftArrow$, rightArrow$).pipe(\\n      share()\\n    );\\n\\n    const timer$ = interval(5000).pipe(\\n        takeUntil(events$),\\n        repeatWhen(source => source),\\n        tap(() => {\\n          if (this.active >= items.length) {\\n            this.active = 0;\\n            items.forEach(item => {\\n              this.animateCarouselItem(item, 0, 300);\\n            });\\n          }\\n        }),\\n        mapTo(this.goToNextPage)\\n      );\\n\\n\\n    merge(events$, timer$).pipe(\\n      tap(val => {\\n        if (val > this.moveThreshold && this.active < items.length) {\\n          this.active++;\\n        } else if (val < -1 * this.moveThreshold && this.active > 1) {\\n          this.active--;\\n        }\\n\\n        items.forEach(item => {\\n          const delta = this.DELTA_DIRECTION_COEFFICIENT *\\n            ((this.active - 1) *\\n              this.el.nativeElement.firstChild.clientWidth);\\n          this.animateCarouselItem(item, delta, 300);\\n        });\\n      }),\\n      takeUntil(this.destroyed$)\\n    ).subscribe();\\n  }\\n\\n  private animateCarouselItem(\\n    item: CarouselItemDirective,\\n    delta?: number,\\n    transitionTime?: number\\n  ): void {\\n    if (!!transitionTime) {\\n      item.setTransition(transitionTime);\\n    }\\n    if (!!delta || delta === 0) {\\n      item.setStyle('transform', `translateX(${delta}px)`);\\n    }\\n  }\\n\\n  public ngOnDestroy() {\\n    this.destroyed$.next();\\n    this.destroyed$.complete();\\n  }\\n}\\n\")), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-ts\",\n    \"metastring\": \"53:54 file=./code/carousel/src/app/carousel/carousel.component.ts title=\\\"map to proper value\\\"\",\n    \"53:54\": true,\n    \"file\": \"./code/carousel/src/app/carousel/carousel.component.ts\",\n    \"title\": \"\\\"map\",\n    \"to\": true,\n    \"proper\": true,\n    \"value\\\"\": true\n  }), \"import { fromEvent, Subject, merge, interval, race, animationFrameScheduler } from 'rxjs';\\nimport {\\n  AfterContentInit,\\n  Component,\\n  ContentChildren,\\n  ElementRef,\\n  QueryList,\\n  OnInit,\\n  OnDestroy\\n} from '@angular/core';\\nimport {\\n  map,\\n  takeLast,\\n  takeUntil,\\n  tap,\\n  switchMap,\\n  filter,\\n  mapTo,\\n  share,\\n  repeatWhen,\\n  observeOn\\n} from 'rxjs/operators';\\n\\nimport { CarouselItemDirective } from './carousel-item.directive';\\nimport { preventEventPropagation } from './util';\\n\\n@Component({\\n  selector: 'app-carousel',\\n  templateUrl: './carousel.component.html',\\n  styleUrls: ['./carousel.component.scss']\\n})\\nexport class CarouselComponent implements\\n  OnInit, AfterContentInit, OnDestroy {\\n\\n  @ContentChildren(CarouselItemDirective) carouselItems:\\n    QueryList<CarouselItemDirective>;\\n\\n  private readonly DELTA_DIRECTION_COEFFICIENT = -1;\\n  private readonly MOVE_THRESHOLD = 15;\\n  private moveThreshold = 0;\\n  private goToPrevPage = 0;\\n  private goToNextPage = 0;\\n  public active = 1;\\n\\n  private destroyed$ = new Subject<void>();\\n\\n  constructor(private el: ElementRef) {\\n  }\\n\\n  ngOnInit(): void {\\n    const clientWidth = this.el.nativeElement.firstChild.clientWidth;\\n    this.moveThreshold = (clientWidth * this.MOVE_THRESHOLD) / 100;\\n    this.goToPrevPage = -1 * this.moveThreshold - 1;\\n    this.goToNextPage = this.moveThreshold + 1;\\n  }\\n\\n  public ngAfterContentInit(): void {\\n    const nativeElement = this.el.nativeElement;\\n    const items = this.carouselItems.toArray();\\n\\n    const touchStart$ = merge(\\n      fromEvent(nativeElement, 'touchstart').pipe(\\n        preventEventPropagation,\\n        map((event: any) => event.touches[0])\\n      ),\\n      fromEvent(nativeElement, 'mousedown').pipe(\\n        preventEventPropagation\\n      )\\n    ).pipe(\\n      tap((e: Event) => {\\n        items.forEach(item => {\\n          this.animateCarouselItem(item, null, 0);\\n        });\\n      })\\n    );\\n\\n    const touchMove$ = (startEvent) => merge(\\n      fromEvent(nativeElement, 'touchmove').pipe(\\n        preventEventPropagation,\\n        map((event: any) => event.touches[0])),\\n      fromEvent(nativeElement, 'mousemove').pipe(\\n        preventEventPropagation\\n      )\\n    ).pipe(\\n      observeOn(animationFrameScheduler),\\n      takeUntil(\\n        race(\\n          fromEvent(nativeElement, 'touchend'),\\n          fromEvent(nativeElement, 'mouseup')\\n        )\\n      ),\\n      map((event) => event.pageX),\\n      map((pageX) => Math.round(startEvent.pageX - pageX)),\\n      tap(data => {\\n        items.forEach(item => {\\n          const delta = this.DELTA_DIRECTION_COEFFICIENT *\\n            ((this.active - 1) *\\n              this.el.nativeElement.firstChild.clientWidth) - data;\\n          this.animateCarouselItem(item, delta, null);\\n        });\\n      }),\\n      takeLast(1)\\n    );\\n\\n    const swipe$ = touchStart$.pipe(\\n      switchMap((startEvent: TouchEvent) => touchMove$(startEvent)),\\n    );\\n\\n    const leftArrow$ = fromEvent(document, 'keydown').pipe(\\n      filter((event: KeyboardEvent) => event.code === 'KeyA'),\\n      mapTo(this.goToPrevPage)\\n    );\\n\\n    const rightArrow$ = fromEvent(document, 'keydown').pipe(\\n      filter((event: KeyboardEvent) => event.code === 'KeyD'),\\n      mapTo(this.goToNextPage)\\n    );\\n\\n    const events$ =  merge(swipe$, leftArrow$, rightArrow$).pipe(\\n      share()\\n    );\\n\\n    const timer$ = interval(5000).pipe(\\n        takeUntil(events$),\\n        repeatWhen(source => source),\\n        tap(() => {\\n          if (this.active >= items.length) {\\n            this.active = 0;\\n            items.forEach(item => {\\n              this.animateCarouselItem(item, 0, 300);\\n            });\\n          }\\n        }),\\n        mapTo(this.goToNextPage)\\n      );\\n\\n\\n    merge(events$, timer$).pipe(\\n      tap(val => {\\n        if (val > this.moveThreshold && this.active < items.length) {\\n          this.active++;\\n        } else if (val < -1 * this.moveThreshold && this.active > 1) {\\n          this.active--;\\n        }\\n\\n        items.forEach(item => {\\n          const delta = this.DELTA_DIRECTION_COEFFICIENT *\\n            ((this.active - 1) *\\n              this.el.nativeElement.firstChild.clientWidth);\\n          this.animateCarouselItem(item, delta, 300);\\n        });\\n      }),\\n      takeUntil(this.destroyed$)\\n    ).subscribe();\\n  }\\n\\n  private animateCarouselItem(\\n    item: CarouselItemDirective,\\n    delta?: number,\\n    transitionTime?: number\\n  ): void {\\n    if (!!transitionTime) {\\n      item.setTransition(transitionTime);\\n    }\\n    if (!!delta || delta === 0) {\\n      item.setStyle('transform', `translateX(${delta}px)`);\\n    }\\n  }\\n\\n  public ngOnDestroy() {\\n    this.destroyed$.next();\\n    this.destroyed$.complete();\\n  }\\n}\\n\")), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-ts\",\n    \"metastring\": \"119:121 file=./code/carousel/src/app/carousel/carousel.component.ts title=\\\"merge into observable\\\"\",\n    \"119:121\": true,\n    \"file\": \"./code/carousel/src/app/carousel/carousel.component.ts\",\n    \"title\": \"\\\"merge\",\n    \"into\": true,\n    \"observable\\\"\": true\n  }), \"import { fromEvent, Subject, merge, interval, race, animationFrameScheduler } from 'rxjs';\\nimport {\\n  AfterContentInit,\\n  Component,\\n  ContentChildren,\\n  ElementRef,\\n  QueryList,\\n  OnInit,\\n  OnDestroy\\n} from '@angular/core';\\nimport {\\n  map,\\n  takeLast,\\n  takeUntil,\\n  tap,\\n  switchMap,\\n  filter,\\n  mapTo,\\n  share,\\n  repeatWhen,\\n  observeOn\\n} from 'rxjs/operators';\\n\\nimport { CarouselItemDirective } from './carousel-item.directive';\\nimport { preventEventPropagation } from './util';\\n\\n@Component({\\n  selector: 'app-carousel',\\n  templateUrl: './carousel.component.html',\\n  styleUrls: ['./carousel.component.scss']\\n})\\nexport class CarouselComponent implements\\n  OnInit, AfterContentInit, OnDestroy {\\n\\n  @ContentChildren(CarouselItemDirective) carouselItems:\\n    QueryList<CarouselItemDirective>;\\n\\n  private readonly DELTA_DIRECTION_COEFFICIENT = -1;\\n  private readonly MOVE_THRESHOLD = 15;\\n  private moveThreshold = 0;\\n  private goToPrevPage = 0;\\n  private goToNextPage = 0;\\n  public active = 1;\\n\\n  private destroyed$ = new Subject<void>();\\n\\n  constructor(private el: ElementRef) {\\n  }\\n\\n  ngOnInit(): void {\\n    const clientWidth = this.el.nativeElement.firstChild.clientWidth;\\n    this.moveThreshold = (clientWidth * this.MOVE_THRESHOLD) / 100;\\n    this.goToPrevPage = -1 * this.moveThreshold - 1;\\n    this.goToNextPage = this.moveThreshold + 1;\\n  }\\n\\n  public ngAfterContentInit(): void {\\n    const nativeElement = this.el.nativeElement;\\n    const items = this.carouselItems.toArray();\\n\\n    const touchStart$ = merge(\\n      fromEvent(nativeElement, 'touchstart').pipe(\\n        preventEventPropagation,\\n        map((event: any) => event.touches[0])\\n      ),\\n      fromEvent(nativeElement, 'mousedown').pipe(\\n        preventEventPropagation\\n      )\\n    ).pipe(\\n      tap((e: Event) => {\\n        items.forEach(item => {\\n          this.animateCarouselItem(item, null, 0);\\n        });\\n      })\\n    );\\n\\n    const touchMove$ = (startEvent) => merge(\\n      fromEvent(nativeElement, 'touchmove').pipe(\\n        preventEventPropagation,\\n        map((event: any) => event.touches[0])),\\n      fromEvent(nativeElement, 'mousemove').pipe(\\n        preventEventPropagation\\n      )\\n    ).pipe(\\n      observeOn(animationFrameScheduler),\\n      takeUntil(\\n        race(\\n          fromEvent(nativeElement, 'touchend'),\\n          fromEvent(nativeElement, 'mouseup')\\n        )\\n      ),\\n      map((event) => event.pageX),\\n      map((pageX) => Math.round(startEvent.pageX - pageX)),\\n      tap(data => {\\n        items.forEach(item => {\\n          const delta = this.DELTA_DIRECTION_COEFFICIENT *\\n            ((this.active - 1) *\\n              this.el.nativeElement.firstChild.clientWidth) - data;\\n          this.animateCarouselItem(item, delta, null);\\n        });\\n      }),\\n      takeLast(1)\\n    );\\n\\n    const swipe$ = touchStart$.pipe(\\n      switchMap((startEvent: TouchEvent) => touchMove$(startEvent)),\\n    );\\n\\n    const leftArrow$ = fromEvent(document, 'keydown').pipe(\\n      filter((event: KeyboardEvent) => event.code === 'KeyA'),\\n      mapTo(this.goToPrevPage)\\n    );\\n\\n    const rightArrow$ = fromEvent(document, 'keydown').pipe(\\n      filter((event: KeyboardEvent) => event.code === 'KeyD'),\\n      mapTo(this.goToNextPage)\\n    );\\n\\n    const events$ =  merge(swipe$, leftArrow$, rightArrow$).pipe(\\n      share()\\n    );\\n\\n    const timer$ = interval(5000).pipe(\\n        takeUntil(events$),\\n        repeatWhen(source => source),\\n        tap(() => {\\n          if (this.active >= items.length) {\\n            this.active = 0;\\n            items.forEach(item => {\\n              this.animateCarouselItem(item, 0, 300);\\n            });\\n          }\\n        }),\\n        mapTo(this.goToNextPage)\\n      );\\n\\n\\n    merge(events$, timer$).pipe(\\n      tap(val => {\\n        if (val > this.moveThreshold && this.active < items.length) {\\n          this.active++;\\n        } else if (val < -1 * this.moveThreshold && this.active > 1) {\\n          this.active--;\\n        }\\n\\n        items.forEach(item => {\\n          const delta = this.DELTA_DIRECTION_COEFFICIENT *\\n            ((this.active - 1) *\\n              this.el.nativeElement.firstChild.clientWidth);\\n          this.animateCarouselItem(item, delta, 300);\\n        });\\n      }),\\n      takeUntil(this.destroyed$)\\n    ).subscribe();\\n  }\\n\\n  private animateCarouselItem(\\n    item: CarouselItemDirective,\\n    delta?: number,\\n    transitionTime?: number\\n  ): void {\\n    if (!!transitionTime) {\\n      item.setTransition(transitionTime);\\n    }\\n    if (!!delta || delta === 0) {\\n      item.setStyle('transform', `translateX(${delta}px)`);\\n    }\\n  }\\n\\n  public ngOnDestroy() {\\n    this.destroyed$.next();\\n    this.destroyed$.complete();\\n  }\\n}\\n\")), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"138\": true,\n    \"className\": \"language-ts\",\n    \"metastring\": \"138 file=./code/carousel/src/app/carousel/carousel.component.ts title=\\\"event observables triggers\\\"\",\n    \"file\": \"./code/carousel/src/app/carousel/carousel.component.ts\",\n    \"title\": \"\\\"event\",\n    \"observables\": true,\n    \"triggers\\\"\": true\n  }), \"import { fromEvent, Subject, merge, interval, race, animationFrameScheduler } from 'rxjs';\\nimport {\\n  AfterContentInit,\\n  Component,\\n  ContentChildren,\\n  ElementRef,\\n  QueryList,\\n  OnInit,\\n  OnDestroy\\n} from '@angular/core';\\nimport {\\n  map,\\n  takeLast,\\n  takeUntil,\\n  tap,\\n  switchMap,\\n  filter,\\n  mapTo,\\n  share,\\n  repeatWhen,\\n  observeOn\\n} from 'rxjs/operators';\\n\\nimport { CarouselItemDirective } from './carousel-item.directive';\\nimport { preventEventPropagation } from './util';\\n\\n@Component({\\n  selector: 'app-carousel',\\n  templateUrl: './carousel.component.html',\\n  styleUrls: ['./carousel.component.scss']\\n})\\nexport class CarouselComponent implements\\n  OnInit, AfterContentInit, OnDestroy {\\n\\n  @ContentChildren(CarouselItemDirective) carouselItems:\\n    QueryList<CarouselItemDirective>;\\n\\n  private readonly DELTA_DIRECTION_COEFFICIENT = -1;\\n  private readonly MOVE_THRESHOLD = 15;\\n  private moveThreshold = 0;\\n  private goToPrevPage = 0;\\n  private goToNextPage = 0;\\n  public active = 1;\\n\\n  private destroyed$ = new Subject<void>();\\n\\n  constructor(private el: ElementRef) {\\n  }\\n\\n  ngOnInit(): void {\\n    const clientWidth = this.el.nativeElement.firstChild.clientWidth;\\n    this.moveThreshold = (clientWidth * this.MOVE_THRESHOLD) / 100;\\n    this.goToPrevPage = -1 * this.moveThreshold - 1;\\n    this.goToNextPage = this.moveThreshold + 1;\\n  }\\n\\n  public ngAfterContentInit(): void {\\n    const nativeElement = this.el.nativeElement;\\n    const items = this.carouselItems.toArray();\\n\\n    const touchStart$ = merge(\\n      fromEvent(nativeElement, 'touchstart').pipe(\\n        preventEventPropagation,\\n        map((event: any) => event.touches[0])\\n      ),\\n      fromEvent(nativeElement, 'mousedown').pipe(\\n        preventEventPropagation\\n      )\\n    ).pipe(\\n      tap((e: Event) => {\\n        items.forEach(item => {\\n          this.animateCarouselItem(item, null, 0);\\n        });\\n      })\\n    );\\n\\n    const touchMove$ = (startEvent) => merge(\\n      fromEvent(nativeElement, 'touchmove').pipe(\\n        preventEventPropagation,\\n        map((event: any) => event.touches[0])),\\n      fromEvent(nativeElement, 'mousemove').pipe(\\n        preventEventPropagation\\n      )\\n    ).pipe(\\n      observeOn(animationFrameScheduler),\\n      takeUntil(\\n        race(\\n          fromEvent(nativeElement, 'touchend'),\\n          fromEvent(nativeElement, 'mouseup')\\n        )\\n      ),\\n      map((event) => event.pageX),\\n      map((pageX) => Math.round(startEvent.pageX - pageX)),\\n      tap(data => {\\n        items.forEach(item => {\\n          const delta = this.DELTA_DIRECTION_COEFFICIENT *\\n            ((this.active - 1) *\\n              this.el.nativeElement.firstChild.clientWidth) - data;\\n          this.animateCarouselItem(item, delta, null);\\n        });\\n      }),\\n      takeLast(1)\\n    );\\n\\n    const swipe$ = touchStart$.pipe(\\n      switchMap((startEvent: TouchEvent) => touchMove$(startEvent)),\\n    );\\n\\n    const leftArrow$ = fromEvent(document, 'keydown').pipe(\\n      filter((event: KeyboardEvent) => event.code === 'KeyA'),\\n      mapTo(this.goToPrevPage)\\n    );\\n\\n    const rightArrow$ = fromEvent(document, 'keydown').pipe(\\n      filter((event: KeyboardEvent) => event.code === 'KeyD'),\\n      mapTo(this.goToNextPage)\\n    );\\n\\n    const events$ =  merge(swipe$, leftArrow$, rightArrow$).pipe(\\n      share()\\n    );\\n\\n    const timer$ = interval(5000).pipe(\\n        takeUntil(events$),\\n        repeatWhen(source => source),\\n        tap(() => {\\n          if (this.active >= items.length) {\\n            this.active = 0;\\n            items.forEach(item => {\\n              this.animateCarouselItem(item, 0, 300);\\n            });\\n          }\\n        }),\\n        mapTo(this.goToNextPage)\\n      );\\n\\n\\n    merge(events$, timer$).pipe(\\n      tap(val => {\\n        if (val > this.moveThreshold && this.active < items.length) {\\n          this.active++;\\n        } else if (val < -1 * this.moveThreshold && this.active > 1) {\\n          this.active--;\\n        }\\n\\n        items.forEach(item => {\\n          const delta = this.DELTA_DIRECTION_COEFFICIENT *\\n            ((this.active - 1) *\\n              this.el.nativeElement.firstChild.clientWidth);\\n          this.animateCarouselItem(item, delta, 300);\\n        });\\n      }),\\n      takeUntil(this.destroyed$)\\n    ).subscribe();\\n  }\\n\\n  private animateCarouselItem(\\n    item: CarouselItemDirective,\\n    delta?: number,\\n    transitionTime?: number\\n  ): void {\\n    if (!!transitionTime) {\\n      item.setTransition(transitionTime);\\n    }\\n    if (!!delta || delta === 0) {\\n      item.setStyle('transform', `translateX(${delta}px)`);\\n    }\\n  }\\n\\n  public ngOnDestroy() {\\n    this.destroyed$.next();\\n    this.destroyed$.complete();\\n  }\\n}\\n\")))), mdx(\"hr\", null), mdx(Styles, {\n    mdxType: \"Styles\"\n  }), mdx(\"main\", null, mdx(CodeSurfer, {\n    theme: vsDarkReal,\n    mdxType: \"CodeSurfer\"\n  }, mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"123\": true,\n    \"className\": \"language-ts\",\n    \"metastring\": \"123 file=./code/carousel/src/app/carousel/carousel.component.ts title=\\\"Add interval for initial delay\\\"\",\n    \"file\": \"./code/carousel/src/app/carousel/carousel.component.ts\",\n    \"title\": \"\\\"Add\",\n    \"interval\": true,\n    \"for\": true,\n    \"initial\": true,\n    \"delay\\\"\": true\n  }), \"import { fromEvent, Subject, merge, interval, race, animationFrameScheduler } from 'rxjs';\\nimport {\\n  AfterContentInit,\\n  Component,\\n  ContentChildren,\\n  ElementRef,\\n  QueryList,\\n  OnInit,\\n  OnDestroy\\n} from '@angular/core';\\nimport {\\n  map,\\n  takeLast,\\n  takeUntil,\\n  tap,\\n  switchMap,\\n  filter,\\n  mapTo,\\n  share,\\n  repeatWhen,\\n  observeOn\\n} from 'rxjs/operators';\\n\\nimport { CarouselItemDirective } from './carousel-item.directive';\\nimport { preventEventPropagation } from './util';\\n\\n@Component({\\n  selector: 'app-carousel',\\n  templateUrl: './carousel.component.html',\\n  styleUrls: ['./carousel.component.scss']\\n})\\nexport class CarouselComponent implements\\n  OnInit, AfterContentInit, OnDestroy {\\n\\n  @ContentChildren(CarouselItemDirective) carouselItems:\\n    QueryList<CarouselItemDirective>;\\n\\n  private readonly DELTA_DIRECTION_COEFFICIENT = -1;\\n  private readonly MOVE_THRESHOLD = 15;\\n  private moveThreshold = 0;\\n  private goToPrevPage = 0;\\n  private goToNextPage = 0;\\n  public active = 1;\\n\\n  private destroyed$ = new Subject<void>();\\n\\n  constructor(private el: ElementRef) {\\n  }\\n\\n  ngOnInit(): void {\\n    const clientWidth = this.el.nativeElement.firstChild.clientWidth;\\n    this.moveThreshold = (clientWidth * this.MOVE_THRESHOLD) / 100;\\n    this.goToPrevPage = -1 * this.moveThreshold - 1;\\n    this.goToNextPage = this.moveThreshold + 1;\\n  }\\n\\n  public ngAfterContentInit(): void {\\n    const nativeElement = this.el.nativeElement;\\n    const items = this.carouselItems.toArray();\\n\\n    const touchStart$ = merge(\\n      fromEvent(nativeElement, 'touchstart').pipe(\\n        preventEventPropagation,\\n        map((event: any) => event.touches[0])\\n      ),\\n      fromEvent(nativeElement, 'mousedown').pipe(\\n        preventEventPropagation\\n      )\\n    ).pipe(\\n      tap((e: Event) => {\\n        items.forEach(item => {\\n          this.animateCarouselItem(item, null, 0);\\n        });\\n      })\\n    );\\n\\n    const touchMove$ = (startEvent) => merge(\\n      fromEvent(nativeElement, 'touchmove').pipe(\\n        preventEventPropagation,\\n        map((event: any) => event.touches[0])),\\n      fromEvent(nativeElement, 'mousemove').pipe(\\n        preventEventPropagation\\n      )\\n    ).pipe(\\n      observeOn(animationFrameScheduler),\\n      takeUntil(\\n        race(\\n          fromEvent(nativeElement, 'touchend'),\\n          fromEvent(nativeElement, 'mouseup')\\n        )\\n      ),\\n      map((event) => event.pageX),\\n      map((pageX) => Math.round(startEvent.pageX - pageX)),\\n      tap(data => {\\n        items.forEach(item => {\\n          const delta = this.DELTA_DIRECTION_COEFFICIENT *\\n            ((this.active - 1) *\\n              this.el.nativeElement.firstChild.clientWidth) - data;\\n          this.animateCarouselItem(item, delta, null);\\n        });\\n      }),\\n      takeLast(1)\\n    );\\n\\n    const swipe$ = touchStart$.pipe(\\n      switchMap((startEvent: TouchEvent) => touchMove$(startEvent)),\\n    );\\n\\n    const leftArrow$ = fromEvent(document, 'keydown').pipe(\\n      filter((event: KeyboardEvent) => event.code === 'KeyA'),\\n      mapTo(this.goToPrevPage)\\n    );\\n\\n    const rightArrow$ = fromEvent(document, 'keydown').pipe(\\n      filter((event: KeyboardEvent) => event.code === 'KeyD'),\\n      mapTo(this.goToNextPage)\\n    );\\n\\n    const events$ =  merge(swipe$, leftArrow$, rightArrow$).pipe(\\n      share()\\n    );\\n\\n    const timer$ = interval(5000).pipe(\\n        takeUntil(events$),\\n        repeatWhen(source => source),\\n        tap(() => {\\n          if (this.active >= items.length) {\\n            this.active = 0;\\n            items.forEach(item => {\\n              this.animateCarouselItem(item, 0, 300);\\n            });\\n          }\\n        }),\\n        mapTo(this.goToNextPage)\\n      );\\n\\n\\n    merge(events$, timer$).pipe(\\n      tap(val => {\\n        if (val > this.moveThreshold && this.active < items.length) {\\n          this.active++;\\n        } else if (val < -1 * this.moveThreshold && this.active > 1) {\\n          this.active--;\\n        }\\n\\n        items.forEach(item => {\\n          const delta = this.DELTA_DIRECTION_COEFFICIENT *\\n            ((this.active - 1) *\\n              this.el.nativeElement.firstChild.clientWidth);\\n          this.animateCarouselItem(item, delta, 300);\\n        });\\n      }),\\n      takeUntil(this.destroyed$)\\n    ).subscribe();\\n  }\\n\\n  private animateCarouselItem(\\n    item: CarouselItemDirective,\\n    delta?: number,\\n    transitionTime?: number\\n  ): void {\\n    if (!!transitionTime) {\\n      item.setTransition(transitionTime);\\n    }\\n    if (!!delta || delta === 0) {\\n      item.setStyle('transform', `translateX(${delta}px)`);\\n    }\\n  }\\n\\n  public ngOnDestroy() {\\n    this.destroyed$.next();\\n    this.destroyed$.complete();\\n  }\\n}\\n\")), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"124\": true,\n    \"className\": \"language-ts\",\n    \"metastring\": \"124 file=./code/carousel/src/app/carousel/carousel.component.ts title=\\\"unsubscribe when an event is emitted\\\"\",\n    \"file\": \"./code/carousel/src/app/carousel/carousel.component.ts\",\n    \"title\": \"\\\"unsubscribe\",\n    \"when\": true,\n    \"an\": true,\n    \"event\": true,\n    \"is\": true,\n    \"emitted\\\"\": true\n  }), \"import { fromEvent, Subject, merge, interval, race, animationFrameScheduler } from 'rxjs';\\nimport {\\n  AfterContentInit,\\n  Component,\\n  ContentChildren,\\n  ElementRef,\\n  QueryList,\\n  OnInit,\\n  OnDestroy\\n} from '@angular/core';\\nimport {\\n  map,\\n  takeLast,\\n  takeUntil,\\n  tap,\\n  switchMap,\\n  filter,\\n  mapTo,\\n  share,\\n  repeatWhen,\\n  observeOn\\n} from 'rxjs/operators';\\n\\nimport { CarouselItemDirective } from './carousel-item.directive';\\nimport { preventEventPropagation } from './util';\\n\\n@Component({\\n  selector: 'app-carousel',\\n  templateUrl: './carousel.component.html',\\n  styleUrls: ['./carousel.component.scss']\\n})\\nexport class CarouselComponent implements\\n  OnInit, AfterContentInit, OnDestroy {\\n\\n  @ContentChildren(CarouselItemDirective) carouselItems:\\n    QueryList<CarouselItemDirective>;\\n\\n  private readonly DELTA_DIRECTION_COEFFICIENT = -1;\\n  private readonly MOVE_THRESHOLD = 15;\\n  private moveThreshold = 0;\\n  private goToPrevPage = 0;\\n  private goToNextPage = 0;\\n  public active = 1;\\n\\n  private destroyed$ = new Subject<void>();\\n\\n  constructor(private el: ElementRef) {\\n  }\\n\\n  ngOnInit(): void {\\n    const clientWidth = this.el.nativeElement.firstChild.clientWidth;\\n    this.moveThreshold = (clientWidth * this.MOVE_THRESHOLD) / 100;\\n    this.goToPrevPage = -1 * this.moveThreshold - 1;\\n    this.goToNextPage = this.moveThreshold + 1;\\n  }\\n\\n  public ngAfterContentInit(): void {\\n    const nativeElement = this.el.nativeElement;\\n    const items = this.carouselItems.toArray();\\n\\n    const touchStart$ = merge(\\n      fromEvent(nativeElement, 'touchstart').pipe(\\n        preventEventPropagation,\\n        map((event: any) => event.touches[0])\\n      ),\\n      fromEvent(nativeElement, 'mousedown').pipe(\\n        preventEventPropagation\\n      )\\n    ).pipe(\\n      tap((e: Event) => {\\n        items.forEach(item => {\\n          this.animateCarouselItem(item, null, 0);\\n        });\\n      })\\n    );\\n\\n    const touchMove$ = (startEvent) => merge(\\n      fromEvent(nativeElement, 'touchmove').pipe(\\n        preventEventPropagation,\\n        map((event: any) => event.touches[0])),\\n      fromEvent(nativeElement, 'mousemove').pipe(\\n        preventEventPropagation\\n      )\\n    ).pipe(\\n      observeOn(animationFrameScheduler),\\n      takeUntil(\\n        race(\\n          fromEvent(nativeElement, 'touchend'),\\n          fromEvent(nativeElement, 'mouseup')\\n        )\\n      ),\\n      map((event) => event.pageX),\\n      map((pageX) => Math.round(startEvent.pageX - pageX)),\\n      tap(data => {\\n        items.forEach(item => {\\n          const delta = this.DELTA_DIRECTION_COEFFICIENT *\\n            ((this.active - 1) *\\n              this.el.nativeElement.firstChild.clientWidth) - data;\\n          this.animateCarouselItem(item, delta, null);\\n        });\\n      }),\\n      takeLast(1)\\n    );\\n\\n    const swipe$ = touchStart$.pipe(\\n      switchMap((startEvent: TouchEvent) => touchMove$(startEvent)),\\n    );\\n\\n    const leftArrow$ = fromEvent(document, 'keydown').pipe(\\n      filter((event: KeyboardEvent) => event.code === 'KeyA'),\\n      mapTo(this.goToPrevPage)\\n    );\\n\\n    const rightArrow$ = fromEvent(document, 'keydown').pipe(\\n      filter((event: KeyboardEvent) => event.code === 'KeyD'),\\n      mapTo(this.goToNextPage)\\n    );\\n\\n    const events$ =  merge(swipe$, leftArrow$, rightArrow$).pipe(\\n      share()\\n    );\\n\\n    const timer$ = interval(5000).pipe(\\n        takeUntil(events$),\\n        repeatWhen(source => source),\\n        tap(() => {\\n          if (this.active >= items.length) {\\n            this.active = 0;\\n            items.forEach(item => {\\n              this.animateCarouselItem(item, 0, 300);\\n            });\\n          }\\n        }),\\n        mapTo(this.goToNextPage)\\n      );\\n\\n\\n    merge(events$, timer$).pipe(\\n      tap(val => {\\n        if (val > this.moveThreshold && this.active < items.length) {\\n          this.active++;\\n        } else if (val < -1 * this.moveThreshold && this.active > 1) {\\n          this.active--;\\n        }\\n\\n        items.forEach(item => {\\n          const delta = this.DELTA_DIRECTION_COEFFICIENT *\\n            ((this.active - 1) *\\n              this.el.nativeElement.firstChild.clientWidth);\\n          this.animateCarouselItem(item, delta, 300);\\n        });\\n      }),\\n      takeUntil(this.destroyed$)\\n    ).subscribe();\\n  }\\n\\n  private animateCarouselItem(\\n    item: CarouselItemDirective,\\n    delta?: number,\\n    transitionTime?: number\\n  ): void {\\n    if (!!transitionTime) {\\n      item.setTransition(transitionTime);\\n    }\\n    if (!!delta || delta === 0) {\\n      item.setStyle('transform', `translateX(${delta}px)`);\\n    }\\n  }\\n\\n  public ngOnDestroy() {\\n    this.destroyed$.next();\\n    this.destroyed$.complete();\\n  }\\n}\\n\")), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"125\": true,\n    \"className\": \"language-ts\",\n    \"metastring\": \"125 file=./code/carousel/src/app/carousel/carousel.component.ts title=\\\"resubscribe in that case\\\"\",\n    \"file\": \"./code/carousel/src/app/carousel/carousel.component.ts\",\n    \"title\": \"\\\"resubscribe\",\n    \"in\": true,\n    \"that\": true,\n    \"case\\\"\": true\n  }), \"import { fromEvent, Subject, merge, interval, race, animationFrameScheduler } from 'rxjs';\\nimport {\\n  AfterContentInit,\\n  Component,\\n  ContentChildren,\\n  ElementRef,\\n  QueryList,\\n  OnInit,\\n  OnDestroy\\n} from '@angular/core';\\nimport {\\n  map,\\n  takeLast,\\n  takeUntil,\\n  tap,\\n  switchMap,\\n  filter,\\n  mapTo,\\n  share,\\n  repeatWhen,\\n  observeOn\\n} from 'rxjs/operators';\\n\\nimport { CarouselItemDirective } from './carousel-item.directive';\\nimport { preventEventPropagation } from './util';\\n\\n@Component({\\n  selector: 'app-carousel',\\n  templateUrl: './carousel.component.html',\\n  styleUrls: ['./carousel.component.scss']\\n})\\nexport class CarouselComponent implements\\n  OnInit, AfterContentInit, OnDestroy {\\n\\n  @ContentChildren(CarouselItemDirective) carouselItems:\\n    QueryList<CarouselItemDirective>;\\n\\n  private readonly DELTA_DIRECTION_COEFFICIENT = -1;\\n  private readonly MOVE_THRESHOLD = 15;\\n  private moveThreshold = 0;\\n  private goToPrevPage = 0;\\n  private goToNextPage = 0;\\n  public active = 1;\\n\\n  private destroyed$ = new Subject<void>();\\n\\n  constructor(private el: ElementRef) {\\n  }\\n\\n  ngOnInit(): void {\\n    const clientWidth = this.el.nativeElement.firstChild.clientWidth;\\n    this.moveThreshold = (clientWidth * this.MOVE_THRESHOLD) / 100;\\n    this.goToPrevPage = -1 * this.moveThreshold - 1;\\n    this.goToNextPage = this.moveThreshold + 1;\\n  }\\n\\n  public ngAfterContentInit(): void {\\n    const nativeElement = this.el.nativeElement;\\n    const items = this.carouselItems.toArray();\\n\\n    const touchStart$ = merge(\\n      fromEvent(nativeElement, 'touchstart').pipe(\\n        preventEventPropagation,\\n        map((event: any) => event.touches[0])\\n      ),\\n      fromEvent(nativeElement, 'mousedown').pipe(\\n        preventEventPropagation\\n      )\\n    ).pipe(\\n      tap((e: Event) => {\\n        items.forEach(item => {\\n          this.animateCarouselItem(item, null, 0);\\n        });\\n      })\\n    );\\n\\n    const touchMove$ = (startEvent) => merge(\\n      fromEvent(nativeElement, 'touchmove').pipe(\\n        preventEventPropagation,\\n        map((event: any) => event.touches[0])),\\n      fromEvent(nativeElement, 'mousemove').pipe(\\n        preventEventPropagation\\n      )\\n    ).pipe(\\n      observeOn(animationFrameScheduler),\\n      takeUntil(\\n        race(\\n          fromEvent(nativeElement, 'touchend'),\\n          fromEvent(nativeElement, 'mouseup')\\n        )\\n      ),\\n      map((event) => event.pageX),\\n      map((pageX) => Math.round(startEvent.pageX - pageX)),\\n      tap(data => {\\n        items.forEach(item => {\\n          const delta = this.DELTA_DIRECTION_COEFFICIENT *\\n            ((this.active - 1) *\\n              this.el.nativeElement.firstChild.clientWidth) - data;\\n          this.animateCarouselItem(item, delta, null);\\n        });\\n      }),\\n      takeLast(1)\\n    );\\n\\n    const swipe$ = touchStart$.pipe(\\n      switchMap((startEvent: TouchEvent) => touchMove$(startEvent)),\\n    );\\n\\n    const leftArrow$ = fromEvent(document, 'keydown').pipe(\\n      filter((event: KeyboardEvent) => event.code === 'KeyA'),\\n      mapTo(this.goToPrevPage)\\n    );\\n\\n    const rightArrow$ = fromEvent(document, 'keydown').pipe(\\n      filter((event: KeyboardEvent) => event.code === 'KeyD'),\\n      mapTo(this.goToNextPage)\\n    );\\n\\n    const events$ =  merge(swipe$, leftArrow$, rightArrow$).pipe(\\n      share()\\n    );\\n\\n    const timer$ = interval(5000).pipe(\\n        takeUntil(events$),\\n        repeatWhen(source => source),\\n        tap(() => {\\n          if (this.active >= items.length) {\\n            this.active = 0;\\n            items.forEach(item => {\\n              this.animateCarouselItem(item, 0, 300);\\n            });\\n          }\\n        }),\\n        mapTo(this.goToNextPage)\\n      );\\n\\n\\n    merge(events$, timer$).pipe(\\n      tap(val => {\\n        if (val > this.moveThreshold && this.active < items.length) {\\n          this.active++;\\n        } else if (val < -1 * this.moveThreshold && this.active > 1) {\\n          this.active--;\\n        }\\n\\n        items.forEach(item => {\\n          const delta = this.DELTA_DIRECTION_COEFFICIENT *\\n            ((this.active - 1) *\\n              this.el.nativeElement.firstChild.clientWidth);\\n          this.animateCarouselItem(item, delta, 300);\\n        });\\n      }),\\n      takeUntil(this.destroyed$)\\n    ).subscribe();\\n  }\\n\\n  private animateCarouselItem(\\n    item: CarouselItemDirective,\\n    delta?: number,\\n    transitionTime?: number\\n  ): void {\\n    if (!!transitionTime) {\\n      item.setTransition(transitionTime);\\n    }\\n    if (!!delta || delta === 0) {\\n      item.setStyle('transform', `translateX(${delta}px)`);\\n    }\\n  }\\n\\n  public ngOnDestroy() {\\n    this.destroyed$.next();\\n    this.destroyed$.complete();\\n  }\\n}\\n\")), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"134\": true,\n    \"className\": \"language-ts\",\n    \"metastring\": \"134 file=./code/carousel/src/app/carousel/carousel.component.ts title=\\\"Go to next page\\\"\",\n    \"file\": \"./code/carousel/src/app/carousel/carousel.component.ts\",\n    \"title\": \"\\\"Go\",\n    \"to\": true,\n    \"next\": true,\n    \"page\\\"\": true\n  }), \"import { fromEvent, Subject, merge, interval, race, animationFrameScheduler } from 'rxjs';\\nimport {\\n  AfterContentInit,\\n  Component,\\n  ContentChildren,\\n  ElementRef,\\n  QueryList,\\n  OnInit,\\n  OnDestroy\\n} from '@angular/core';\\nimport {\\n  map,\\n  takeLast,\\n  takeUntil,\\n  tap,\\n  switchMap,\\n  filter,\\n  mapTo,\\n  share,\\n  repeatWhen,\\n  observeOn\\n} from 'rxjs/operators';\\n\\nimport { CarouselItemDirective } from './carousel-item.directive';\\nimport { preventEventPropagation } from './util';\\n\\n@Component({\\n  selector: 'app-carousel',\\n  templateUrl: './carousel.component.html',\\n  styleUrls: ['./carousel.component.scss']\\n})\\nexport class CarouselComponent implements\\n  OnInit, AfterContentInit, OnDestroy {\\n\\n  @ContentChildren(CarouselItemDirective) carouselItems:\\n    QueryList<CarouselItemDirective>;\\n\\n  private readonly DELTA_DIRECTION_COEFFICIENT = -1;\\n  private readonly MOVE_THRESHOLD = 15;\\n  private moveThreshold = 0;\\n  private goToPrevPage = 0;\\n  private goToNextPage = 0;\\n  public active = 1;\\n\\n  private destroyed$ = new Subject<void>();\\n\\n  constructor(private el: ElementRef) {\\n  }\\n\\n  ngOnInit(): void {\\n    const clientWidth = this.el.nativeElement.firstChild.clientWidth;\\n    this.moveThreshold = (clientWidth * this.MOVE_THRESHOLD) / 100;\\n    this.goToPrevPage = -1 * this.moveThreshold - 1;\\n    this.goToNextPage = this.moveThreshold + 1;\\n  }\\n\\n  public ngAfterContentInit(): void {\\n    const nativeElement = this.el.nativeElement;\\n    const items = this.carouselItems.toArray();\\n\\n    const touchStart$ = merge(\\n      fromEvent(nativeElement, 'touchstart').pipe(\\n        preventEventPropagation,\\n        map((event: any) => event.touches[0])\\n      ),\\n      fromEvent(nativeElement, 'mousedown').pipe(\\n        preventEventPropagation\\n      )\\n    ).pipe(\\n      tap((e: Event) => {\\n        items.forEach(item => {\\n          this.animateCarouselItem(item, null, 0);\\n        });\\n      })\\n    );\\n\\n    const touchMove$ = (startEvent) => merge(\\n      fromEvent(nativeElement, 'touchmove').pipe(\\n        preventEventPropagation,\\n        map((event: any) => event.touches[0])),\\n      fromEvent(nativeElement, 'mousemove').pipe(\\n        preventEventPropagation\\n      )\\n    ).pipe(\\n      observeOn(animationFrameScheduler),\\n      takeUntil(\\n        race(\\n          fromEvent(nativeElement, 'touchend'),\\n          fromEvent(nativeElement, 'mouseup')\\n        )\\n      ),\\n      map((event) => event.pageX),\\n      map((pageX) => Math.round(startEvent.pageX - pageX)),\\n      tap(data => {\\n        items.forEach(item => {\\n          const delta = this.DELTA_DIRECTION_COEFFICIENT *\\n            ((this.active - 1) *\\n              this.el.nativeElement.firstChild.clientWidth) - data;\\n          this.animateCarouselItem(item, delta, null);\\n        });\\n      }),\\n      takeLast(1)\\n    );\\n\\n    const swipe$ = touchStart$.pipe(\\n      switchMap((startEvent: TouchEvent) => touchMove$(startEvent)),\\n    );\\n\\n    const leftArrow$ = fromEvent(document, 'keydown').pipe(\\n      filter((event: KeyboardEvent) => event.code === 'KeyA'),\\n      mapTo(this.goToPrevPage)\\n    );\\n\\n    const rightArrow$ = fromEvent(document, 'keydown').pipe(\\n      filter((event: KeyboardEvent) => event.code === 'KeyD'),\\n      mapTo(this.goToNextPage)\\n    );\\n\\n    const events$ =  merge(swipe$, leftArrow$, rightArrow$).pipe(\\n      share()\\n    );\\n\\n    const timer$ = interval(5000).pipe(\\n        takeUntil(events$),\\n        repeatWhen(source => source),\\n        tap(() => {\\n          if (this.active >= items.length) {\\n            this.active = 0;\\n            items.forEach(item => {\\n              this.animateCarouselItem(item, 0, 300);\\n            });\\n          }\\n        }),\\n        mapTo(this.goToNextPage)\\n      );\\n\\n\\n    merge(events$, timer$).pipe(\\n      tap(val => {\\n        if (val > this.moveThreshold && this.active < items.length) {\\n          this.active++;\\n        } else if (val < -1 * this.moveThreshold && this.active > 1) {\\n          this.active--;\\n        }\\n\\n        items.forEach(item => {\\n          const delta = this.DELTA_DIRECTION_COEFFICIENT *\\n            ((this.active - 1) *\\n              this.el.nativeElement.firstChild.clientWidth);\\n          this.animateCarouselItem(item, delta, 300);\\n        });\\n      }),\\n      takeUntil(this.destroyed$)\\n    ).subscribe();\\n  }\\n\\n  private animateCarouselItem(\\n    item: CarouselItemDirective,\\n    delta?: number,\\n    transitionTime?: number\\n  ): void {\\n    if (!!transitionTime) {\\n      item.setTransition(transitionTime);\\n    }\\n    if (!!delta || delta === 0) {\\n      item.setStyle('transform', `translateX(${delta}px)`);\\n    }\\n  }\\n\\n  public ngOnDestroy() {\\n    this.destroyed$.next();\\n    this.destroyed$.complete();\\n  }\\n}\\n\")), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-ts\",\n    \"metastring\": \"126:133 file=./code/carousel/src/app/carousel/carousel.component.ts title=\\\"Go to first page when exceeding\\\"\",\n    \"126:133\": true,\n    \"file\": \"./code/carousel/src/app/carousel/carousel.component.ts\",\n    \"title\": \"\\\"Go\",\n    \"to\": true,\n    \"first\": true,\n    \"page\": true,\n    \"when\": true,\n    \"exceeding\\\"\": true\n  }), \"import { fromEvent, Subject, merge, interval, race, animationFrameScheduler } from 'rxjs';\\nimport {\\n  AfterContentInit,\\n  Component,\\n  ContentChildren,\\n  ElementRef,\\n  QueryList,\\n  OnInit,\\n  OnDestroy\\n} from '@angular/core';\\nimport {\\n  map,\\n  takeLast,\\n  takeUntil,\\n  tap,\\n  switchMap,\\n  filter,\\n  mapTo,\\n  share,\\n  repeatWhen,\\n  observeOn\\n} from 'rxjs/operators';\\n\\nimport { CarouselItemDirective } from './carousel-item.directive';\\nimport { preventEventPropagation } from './util';\\n\\n@Component({\\n  selector: 'app-carousel',\\n  templateUrl: './carousel.component.html',\\n  styleUrls: ['./carousel.component.scss']\\n})\\nexport class CarouselComponent implements\\n  OnInit, AfterContentInit, OnDestroy {\\n\\n  @ContentChildren(CarouselItemDirective) carouselItems:\\n    QueryList<CarouselItemDirective>;\\n\\n  private readonly DELTA_DIRECTION_COEFFICIENT = -1;\\n  private readonly MOVE_THRESHOLD = 15;\\n  private moveThreshold = 0;\\n  private goToPrevPage = 0;\\n  private goToNextPage = 0;\\n  public active = 1;\\n\\n  private destroyed$ = new Subject<void>();\\n\\n  constructor(private el: ElementRef) {\\n  }\\n\\n  ngOnInit(): void {\\n    const clientWidth = this.el.nativeElement.firstChild.clientWidth;\\n    this.moveThreshold = (clientWidth * this.MOVE_THRESHOLD) / 100;\\n    this.goToPrevPage = -1 * this.moveThreshold - 1;\\n    this.goToNextPage = this.moveThreshold + 1;\\n  }\\n\\n  public ngAfterContentInit(): void {\\n    const nativeElement = this.el.nativeElement;\\n    const items = this.carouselItems.toArray();\\n\\n    const touchStart$ = merge(\\n      fromEvent(nativeElement, 'touchstart').pipe(\\n        preventEventPropagation,\\n        map((event: any) => event.touches[0])\\n      ),\\n      fromEvent(nativeElement, 'mousedown').pipe(\\n        preventEventPropagation\\n      )\\n    ).pipe(\\n      tap((e: Event) => {\\n        items.forEach(item => {\\n          this.animateCarouselItem(item, null, 0);\\n        });\\n      })\\n    );\\n\\n    const touchMove$ = (startEvent) => merge(\\n      fromEvent(nativeElement, 'touchmove').pipe(\\n        preventEventPropagation,\\n        map((event: any) => event.touches[0])),\\n      fromEvent(nativeElement, 'mousemove').pipe(\\n        preventEventPropagation\\n      )\\n    ).pipe(\\n      observeOn(animationFrameScheduler),\\n      takeUntil(\\n        race(\\n          fromEvent(nativeElement, 'touchend'),\\n          fromEvent(nativeElement, 'mouseup')\\n        )\\n      ),\\n      map((event) => event.pageX),\\n      map((pageX) => Math.round(startEvent.pageX - pageX)),\\n      tap(data => {\\n        items.forEach(item => {\\n          const delta = this.DELTA_DIRECTION_COEFFICIENT *\\n            ((this.active - 1) *\\n              this.el.nativeElement.firstChild.clientWidth) - data;\\n          this.animateCarouselItem(item, delta, null);\\n        });\\n      }),\\n      takeLast(1)\\n    );\\n\\n    const swipe$ = touchStart$.pipe(\\n      switchMap((startEvent: TouchEvent) => touchMove$(startEvent)),\\n    );\\n\\n    const leftArrow$ = fromEvent(document, 'keydown').pipe(\\n      filter((event: KeyboardEvent) => event.code === 'KeyA'),\\n      mapTo(this.goToPrevPage)\\n    );\\n\\n    const rightArrow$ = fromEvent(document, 'keydown').pipe(\\n      filter((event: KeyboardEvent) => event.code === 'KeyD'),\\n      mapTo(this.goToNextPage)\\n    );\\n\\n    const events$ =  merge(swipe$, leftArrow$, rightArrow$).pipe(\\n      share()\\n    );\\n\\n    const timer$ = interval(5000).pipe(\\n        takeUntil(events$),\\n        repeatWhen(source => source),\\n        tap(() => {\\n          if (this.active >= items.length) {\\n            this.active = 0;\\n            items.forEach(item => {\\n              this.animateCarouselItem(item, 0, 300);\\n            });\\n          }\\n        }),\\n        mapTo(this.goToNextPage)\\n      );\\n\\n\\n    merge(events$, timer$).pipe(\\n      tap(val => {\\n        if (val > this.moveThreshold && this.active < items.length) {\\n          this.active++;\\n        } else if (val < -1 * this.moveThreshold && this.active > 1) {\\n          this.active--;\\n        }\\n\\n        items.forEach(item => {\\n          const delta = this.DELTA_DIRECTION_COEFFICIENT *\\n            ((this.active - 1) *\\n              this.el.nativeElement.firstChild.clientWidth);\\n          this.animateCarouselItem(item, delta, 300);\\n        });\\n      }),\\n      takeUntil(this.destroyed$)\\n    ).subscribe();\\n  }\\n\\n  private animateCarouselItem(\\n    item: CarouselItemDirective,\\n    delta?: number,\\n    transitionTime?: number\\n  ): void {\\n    if (!!transitionTime) {\\n      item.setTransition(transitionTime);\\n    }\\n    if (!!delta || delta === 0) {\\n      item.setStyle('transform', `translateX(${delta}px)`);\\n    }\\n  }\\n\\n  public ngOnDestroy() {\\n    this.destroyed$.next();\\n    this.destroyed$.complete();\\n  }\\n}\\n\")), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"138\": true,\n    \"className\": \"language-ts\",\n    \"metastring\": \"138 file=./code/carousel/src/app/carousel/carousel.component.ts title=\\\"timer observable triggers\\\"\",\n    \"file\": \"./code/carousel/src/app/carousel/carousel.component.ts\",\n    \"title\": \"\\\"timer\",\n    \"observable\": true,\n    \"triggers\\\"\": true\n  }), \"import { fromEvent, Subject, merge, interval, race, animationFrameScheduler } from 'rxjs';\\nimport {\\n  AfterContentInit,\\n  Component,\\n  ContentChildren,\\n  ElementRef,\\n  QueryList,\\n  OnInit,\\n  OnDestroy\\n} from '@angular/core';\\nimport {\\n  map,\\n  takeLast,\\n  takeUntil,\\n  tap,\\n  switchMap,\\n  filter,\\n  mapTo,\\n  share,\\n  repeatWhen,\\n  observeOn\\n} from 'rxjs/operators';\\n\\nimport { CarouselItemDirective } from './carousel-item.directive';\\nimport { preventEventPropagation } from './util';\\n\\n@Component({\\n  selector: 'app-carousel',\\n  templateUrl: './carousel.component.html',\\n  styleUrls: ['./carousel.component.scss']\\n})\\nexport class CarouselComponent implements\\n  OnInit, AfterContentInit, OnDestroy {\\n\\n  @ContentChildren(CarouselItemDirective) carouselItems:\\n    QueryList<CarouselItemDirective>;\\n\\n  private readonly DELTA_DIRECTION_COEFFICIENT = -1;\\n  private readonly MOVE_THRESHOLD = 15;\\n  private moveThreshold = 0;\\n  private goToPrevPage = 0;\\n  private goToNextPage = 0;\\n  public active = 1;\\n\\n  private destroyed$ = new Subject<void>();\\n\\n  constructor(private el: ElementRef) {\\n  }\\n\\n  ngOnInit(): void {\\n    const clientWidth = this.el.nativeElement.firstChild.clientWidth;\\n    this.moveThreshold = (clientWidth * this.MOVE_THRESHOLD) / 100;\\n    this.goToPrevPage = -1 * this.moveThreshold - 1;\\n    this.goToNextPage = this.moveThreshold + 1;\\n  }\\n\\n  public ngAfterContentInit(): void {\\n    const nativeElement = this.el.nativeElement;\\n    const items = this.carouselItems.toArray();\\n\\n    const touchStart$ = merge(\\n      fromEvent(nativeElement, 'touchstart').pipe(\\n        preventEventPropagation,\\n        map((event: any) => event.touches[0])\\n      ),\\n      fromEvent(nativeElement, 'mousedown').pipe(\\n        preventEventPropagation\\n      )\\n    ).pipe(\\n      tap((e: Event) => {\\n        items.forEach(item => {\\n          this.animateCarouselItem(item, null, 0);\\n        });\\n      })\\n    );\\n\\n    const touchMove$ = (startEvent) => merge(\\n      fromEvent(nativeElement, 'touchmove').pipe(\\n        preventEventPropagation,\\n        map((event: any) => event.touches[0])),\\n      fromEvent(nativeElement, 'mousemove').pipe(\\n        preventEventPropagation\\n      )\\n    ).pipe(\\n      observeOn(animationFrameScheduler),\\n      takeUntil(\\n        race(\\n          fromEvent(nativeElement, 'touchend'),\\n          fromEvent(nativeElement, 'mouseup')\\n        )\\n      ),\\n      map((event) => event.pageX),\\n      map((pageX) => Math.round(startEvent.pageX - pageX)),\\n      tap(data => {\\n        items.forEach(item => {\\n          const delta = this.DELTA_DIRECTION_COEFFICIENT *\\n            ((this.active - 1) *\\n              this.el.nativeElement.firstChild.clientWidth) - data;\\n          this.animateCarouselItem(item, delta, null);\\n        });\\n      }),\\n      takeLast(1)\\n    );\\n\\n    const swipe$ = touchStart$.pipe(\\n      switchMap((startEvent: TouchEvent) => touchMove$(startEvent)),\\n    );\\n\\n    const leftArrow$ = fromEvent(document, 'keydown').pipe(\\n      filter((event: KeyboardEvent) => event.code === 'KeyA'),\\n      mapTo(this.goToPrevPage)\\n    );\\n\\n    const rightArrow$ = fromEvent(document, 'keydown').pipe(\\n      filter((event: KeyboardEvent) => event.code === 'KeyD'),\\n      mapTo(this.goToNextPage)\\n    );\\n\\n    const events$ =  merge(swipe$, leftArrow$, rightArrow$).pipe(\\n      share()\\n    );\\n\\n    const timer$ = interval(5000).pipe(\\n        takeUntil(events$),\\n        repeatWhen(source => source),\\n        tap(() => {\\n          if (this.active >= items.length) {\\n            this.active = 0;\\n            items.forEach(item => {\\n              this.animateCarouselItem(item, 0, 300);\\n            });\\n          }\\n        }),\\n        mapTo(this.goToNextPage)\\n      );\\n\\n\\n    merge(events$, timer$).pipe(\\n      tap(val => {\\n        if (val > this.moveThreshold && this.active < items.length) {\\n          this.active++;\\n        } else if (val < -1 * this.moveThreshold && this.active > 1) {\\n          this.active--;\\n        }\\n\\n        items.forEach(item => {\\n          const delta = this.DELTA_DIRECTION_COEFFICIENT *\\n            ((this.active - 1) *\\n              this.el.nativeElement.firstChild.clientWidth);\\n          this.animateCarouselItem(item, delta, 300);\\n        });\\n      }),\\n      takeUntil(this.destroyed$)\\n    ).subscribe();\\n  }\\n\\n  private animateCarouselItem(\\n    item: CarouselItemDirective,\\n    delta?: number,\\n    transitionTime?: number\\n  ): void {\\n    if (!!transitionTime) {\\n      item.setTransition(transitionTime);\\n    }\\n    if (!!delta || delta === 0) {\\n      item.setStyle('transform', `translateX(${delta}px)`);\\n    }\\n  }\\n\\n  public ngOnDestroy() {\\n    this.destroyed$.next();\\n    this.destroyed$.complete();\\n  }\\n}\\n\")))), mdx(\"hr\", null), mdx(Styles, {\n    mdxType: \"Styles\"\n  }), mdx(\"main\", null, mdx(\"div\", {\n    style: {\n      display: 'flex',\n      width: '100%',\n      height: '100%',\n      alignItems: 'center',\n      justifyContent: 'center'\n    }\n  }, mdx(\"h1\", null, \" What about \", mdx(\"span\", {\n    className: \"primary\"\n  }, \"V7\"), \" and beyond \")), mdx(Footer, {\n    mdxType: \"Footer\"\n  })), mdx(\"hr\", null), mdx(Styles, {\n    mdxType: \"Styles\"\n  }), mdx(\"main\", null, mdx(\"div\", {\n    style: {\n      width: \"100%\",\n      height: \"100%\",\n      backgroundSize: \"cover\",\n      backgroundPosition: \"50% 50%\",\n      backgroundRepeat: \"no-repeat\",\n      backgroundImage: \"url(\".concat(rxjs7Png, \")\")\n    },\n    role: \"img\",\n    \"aria-label\": \"mindmap with new features in rxjs 7 which are improved typings, animationFrame Observable and preparation for the next version\"\n  })), mdx(\"hr\", null), mdx(Styles, {\n    mdxType: \"Styles\"\n  }), mdx(\"main\", null, mdx(CodeSurfer, {\n    theme: vsDarkReal,\n    mdxType: \"CodeSurfer\"\n  }, mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-ts\",\n    \"metastring\": \"1:8 file=./code/typing-example.ts title=\\\"Improved Typings\\\"\",\n    \"1:8\": true,\n    \"file\": \"./code/typing-example.ts\",\n    \"title\": \"\\\"Improved\",\n    \"Typings\\\"\": true\n  }), \"import { timer, of, concat } from \\\"rxjs\\\";\\nimport { switchMap, reduce, filter } from 'rxjs/operators';\\n\\nconst isOnline = window.navigator.onLine;\\n\\nconst obs$ = timer(0, 1000).pipe(\\n    switchMap(() => isOnline ? of(1): of('2') )\\n)\\n/** \\n * RxJS <  7: obs$: Observable<{}>;\\n * RxJS >= 7: obs$: Observable<string | number>;\\n */\\n\\nconst concatObs$ = concat(of(1), of('a'), of(2), of(true), of(3), of([1, 2, 3]), of(4)); \\n/** \\n * RxJS <  7: Observable<unknown>\\n * RxJS >= 7: Observable<string | number | boolean | number[]>\\n */ \\n\\nconst source = of(1, 2, 3).pipe(reduce((a: any, v) => '' + v));\\n/** \\n * RxJS <  7: Observable<any>\\n * RxJS >= 7: Observable<string>\\n */ \\n\\nconst filter$ = of(0, 1, 2).pipe(filter(Boolean));\\n/** \\n * RxJS <  7: Observable<unknown>\\n * RxJS >= 7: Observable<number>\\n */\\n\")), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-ts\",\n    \"metastring\": \"6:12 file=./code/typing-example.ts title=\\\"Proper Type Inference for generator functions\\\"\",\n    \"6:12\": true,\n    \"file\": \"./code/typing-example.ts\",\n    \"title\": \"\\\"Proper\",\n    \"Type\": true,\n    \"Inference\": true,\n    \"for\": true,\n    \"generator\": true,\n    \"functions\\\"\": true\n  }), \"import { timer, of, concat } from \\\"rxjs\\\";\\nimport { switchMap, reduce, filter } from 'rxjs/operators';\\n\\nconst isOnline = window.navigator.onLine;\\n\\nconst obs$ = timer(0, 1000).pipe(\\n    switchMap(() => isOnline ? of(1): of('2') )\\n)\\n/** \\n * RxJS <  7: obs$: Observable<{}>;\\n * RxJS >= 7: obs$: Observable<string | number>;\\n */\\n\\nconst concatObs$ = concat(of(1), of('a'), of(2), of(true), of(3), of([1, 2, 3]), of(4)); \\n/** \\n * RxJS <  7: Observable<unknown>\\n * RxJS >= 7: Observable<string | number | boolean | number[]>\\n */ \\n\\nconst source = of(1, 2, 3).pipe(reduce((a: any, v) => '' + v));\\n/** \\n * RxJS <  7: Observable<any>\\n * RxJS >= 7: Observable<string>\\n */ \\n\\nconst filter$ = of(0, 1, 2).pipe(filter(Boolean));\\n/** \\n * RxJS <  7: Observable<unknown>\\n * RxJS >= 7: Observable<number>\\n */\\n\")), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-ts\",\n    \"metastring\": \"14:18 file=./code/typing-example.ts title=\\\"Improved Typings for concat Operator\\\"\",\n    \"14:18\": true,\n    \"file\": \"./code/typing-example.ts\",\n    \"title\": \"\\\"Improved\",\n    \"Typings\": true,\n    \"for\": true,\n    \"concat\": true,\n    \"Operator\\\"\": true\n  }), \"import { timer, of, concat } from \\\"rxjs\\\";\\nimport { switchMap, reduce, filter } from 'rxjs/operators';\\n\\nconst isOnline = window.navigator.onLine;\\n\\nconst obs$ = timer(0, 1000).pipe(\\n    switchMap(() => isOnline ? of(1): of('2') )\\n)\\n/** \\n * RxJS <  7: obs$: Observable<{}>;\\n * RxJS >= 7: obs$: Observable<string | number>;\\n */\\n\\nconst concatObs$ = concat(of(1), of('a'), of(2), of(true), of(3), of([1, 2, 3]), of(4)); \\n/** \\n * RxJS <  7: Observable<unknown>\\n * RxJS >= 7: Observable<string | number | boolean | number[]>\\n */ \\n\\nconst source = of(1, 2, 3).pipe(reduce((a: any, v) => '' + v));\\n/** \\n * RxJS <  7: Observable<any>\\n * RxJS >= 7: Observable<string>\\n */ \\n\\nconst filter$ = of(0, 1, 2).pipe(filter(Boolean));\\n/** \\n * RxJS <  7: Observable<unknown>\\n * RxJS >= 7: Observable<number>\\n */\\n\")), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-ts\",\n    \"metastring\": \"20:24 file=./code/typing-example.ts title=\\\"Improved Typings for reduce and scan Operator\\\"\",\n    \"20:24\": true,\n    \"file\": \"./code/typing-example.ts\",\n    \"title\": \"\\\"Improved\",\n    \"Typings\": true,\n    \"for\": true,\n    \"reduce\": true,\n    \"and\": true,\n    \"scan\": true,\n    \"Operator\\\"\": true\n  }), \"import { timer, of, concat } from \\\"rxjs\\\";\\nimport { switchMap, reduce, filter } from 'rxjs/operators';\\n\\nconst isOnline = window.navigator.onLine;\\n\\nconst obs$ = timer(0, 1000).pipe(\\n    switchMap(() => isOnline ? of(1): of('2') )\\n)\\n/** \\n * RxJS <  7: obs$: Observable<{}>;\\n * RxJS >= 7: obs$: Observable<string | number>;\\n */\\n\\nconst concatObs$ = concat(of(1), of('a'), of(2), of(true), of(3), of([1, 2, 3]), of(4)); \\n/** \\n * RxJS <  7: Observable<unknown>\\n * RxJS >= 7: Observable<string | number | boolean | number[]>\\n */ \\n\\nconst source = of(1, 2, 3).pipe(reduce((a: any, v) => '' + v));\\n/** \\n * RxJS <  7: Observable<any>\\n * RxJS >= 7: Observable<string>\\n */ \\n\\nconst filter$ = of(0, 1, 2).pipe(filter(Boolean));\\n/** \\n * RxJS <  7: Observable<unknown>\\n * RxJS >= 7: Observable<number>\\n */\\n\")), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-ts\",\n    \"metastring\": \"26:30 file=./code/typing-example.ts title=\\\"Properly infer Type with Boolean constructor\\\"\",\n    \"26:30\": true,\n    \"file\": \"./code/typing-example.ts\",\n    \"title\": \"\\\"Properly\",\n    \"infer\": true,\n    \"Type\": true,\n    \"with\": true,\n    \"Boolean\": true,\n    \"constructor\\\"\": true\n  }), \"import { timer, of, concat } from \\\"rxjs\\\";\\nimport { switchMap, reduce, filter } from 'rxjs/operators';\\n\\nconst isOnline = window.navigator.onLine;\\n\\nconst obs$ = timer(0, 1000).pipe(\\n    switchMap(() => isOnline ? of(1): of('2') )\\n)\\n/** \\n * RxJS <  7: obs$: Observable<{}>;\\n * RxJS >= 7: obs$: Observable<string | number>;\\n */\\n\\nconst concatObs$ = concat(of(1), of('a'), of(2), of(true), of(3), of([1, 2, 3]), of(4)); \\n/** \\n * RxJS <  7: Observable<unknown>\\n * RxJS >= 7: Observable<string | number | boolean | number[]>\\n */ \\n\\nconst source = of(1, 2, 3).pipe(reduce((a: any, v) => '' + v));\\n/** \\n * RxJS <  7: Observable<any>\\n * RxJS >= 7: Observable<string>\\n */ \\n\\nconst filter$ = of(0, 1, 2).pipe(filter(Boolean));\\n/** \\n * RxJS <  7: Observable<unknown>\\n * RxJS >= 7: Observable<number>\\n */\\n\"))), mdx(Footer, {\n    mdxType: \"Footer\"\n  })), mdx(\"hr\", null), mdx(Styles, {\n    mdxType: \"Styles\"\n  }), mdx(\"main\", null, mdx(CodeSurfer, {\n    theme: vsDarkReal,\n    mdxType: \"CodeSurfer\"\n  }, mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-ts\",\n    \"metastring\": \"2:5 file=./code/animation-frame-example.ts title=\\\"AnimationFrame Observable\\\"\",\n    \"2:5\": true,\n    \"file\": \"./code/animation-frame-example.ts\",\n    \"title\": \"\\\"AnimationFrame\",\n    \"Observable\\\"\": true\n  }), \"import { map, takeWhile, endWith } from 'rxjs/operators';\\nimport { animationFrames } from 'rxjs';\\n\\n// Log the elapsed milliseconds at each animation frame.\\nanimationFrames().subscribe(elapsed => console.log(elapsed));\\n\\nexport function tween(start: number, end: number, duration: number) {\\n    const diff = end - start;\\n    return animationFrames().pipe(\\n        // Figure out what percentage of time has passed\\n        map(elapsed => elapsed / duration),\\n        // Take the vector while less than 100%\\n        takeWhile(v => v < 1),\\n        // Finish with 100%\\n        endWith(1),\\n        // Calculate the distance traveled between start and end\\n        map(v => v * diff + start)\\n    );\\n}\\n\\n// Setup a div for us to move around\\nconst div = document.createElement('div');\\ndocument.body.appendChild(div);\\ndiv.style.position = 'absolute';\\ndiv.style.width = '40px';\\ndiv.style.height = '40px';\\ndiv.style.backgroundColor = 'lime';\\ndiv.style.transform = 'translate3d(10px, 0, 0)';\\n\\ntween(10, 400, 4000).subscribe(x => {\\n    div.style.transform = `translate3d(${x}px, 0, 0)`;\\n});\\n\")), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-ts\",\n    \"metastring\": \"7:19 file=./code/animation-frame-example.ts title=\\\"Use for smooth animations\\\"\",\n    \"7:19\": true,\n    \"file\": \"./code/animation-frame-example.ts\",\n    \"title\": \"\\\"Use\",\n    \"for\": true,\n    \"smooth\": true,\n    \"animations\\\"\": true\n  }), \"import { map, takeWhile, endWith } from 'rxjs/operators';\\nimport { animationFrames } from 'rxjs';\\n\\n// Log the elapsed milliseconds at each animation frame.\\nanimationFrames().subscribe(elapsed => console.log(elapsed));\\n\\nexport function tween(start: number, end: number, duration: number) {\\n    const diff = end - start;\\n    return animationFrames().pipe(\\n        // Figure out what percentage of time has passed\\n        map(elapsed => elapsed / duration),\\n        // Take the vector while less than 100%\\n        takeWhile(v => v < 1),\\n        // Finish with 100%\\n        endWith(1),\\n        // Calculate the distance traveled between start and end\\n        map(v => v * diff + start)\\n    );\\n}\\n\\n// Setup a div for us to move around\\nconst div = document.createElement('div');\\ndocument.body.appendChild(div);\\ndiv.style.position = 'absolute';\\ndiv.style.width = '40px';\\ndiv.style.height = '40px';\\ndiv.style.backgroundColor = 'lime';\\ndiv.style.transform = 'translate3d(10px, 0, 0)';\\n\\ntween(10, 400, 4000).subscribe(x => {\\n    div.style.transform = `translate3d(${x}px, 0, 0)`;\\n});\\n\")), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-ts\",\n    \"metastring\": \"21:28 file=./code/animation-frame-example.ts title=\\\"Place Element\\\"\",\n    \"21:28\": true,\n    \"file\": \"./code/animation-frame-example.ts\",\n    \"title\": \"\\\"Place\",\n    \"Element\\\"\": true\n  }), \"import { map, takeWhile, endWith } from 'rxjs/operators';\\nimport { animationFrames } from 'rxjs';\\n\\n// Log the elapsed milliseconds at each animation frame.\\nanimationFrames().subscribe(elapsed => console.log(elapsed));\\n\\nexport function tween(start: number, end: number, duration: number) {\\n    const diff = end - start;\\n    return animationFrames().pipe(\\n        // Figure out what percentage of time has passed\\n        map(elapsed => elapsed / duration),\\n        // Take the vector while less than 100%\\n        takeWhile(v => v < 1),\\n        // Finish with 100%\\n        endWith(1),\\n        // Calculate the distance traveled between start and end\\n        map(v => v * diff + start)\\n    );\\n}\\n\\n// Setup a div for us to move around\\nconst div = document.createElement('div');\\ndocument.body.appendChild(div);\\ndiv.style.position = 'absolute';\\ndiv.style.width = '40px';\\ndiv.style.height = '40px';\\ndiv.style.backgroundColor = 'lime';\\ndiv.style.transform = 'translate3d(10px, 0, 0)';\\n\\ntween(10, 400, 4000).subscribe(x => {\\n    div.style.transform = `translate3d(${x}px, 0, 0)`;\\n});\\n\")), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-ts\",\n    \"metastring\": \"30:32 file=./code/animation-frame-example.ts title=\\\"Let it animate\\\"\",\n    \"30:32\": true,\n    \"file\": \"./code/animation-frame-example.ts\",\n    \"title\": \"\\\"Let\",\n    \"it\": true,\n    \"animate\\\"\": true\n  }), \"import { map, takeWhile, endWith } from 'rxjs/operators';\\nimport { animationFrames } from 'rxjs';\\n\\n// Log the elapsed milliseconds at each animation frame.\\nanimationFrames().subscribe(elapsed => console.log(elapsed));\\n\\nexport function tween(start: number, end: number, duration: number) {\\n    const diff = end - start;\\n    return animationFrames().pipe(\\n        // Figure out what percentage of time has passed\\n        map(elapsed => elapsed / duration),\\n        // Take the vector while less than 100%\\n        takeWhile(v => v < 1),\\n        // Finish with 100%\\n        endWith(1),\\n        // Calculate the distance traveled between start and end\\n        map(v => v * diff + start)\\n    );\\n}\\n\\n// Setup a div for us to move around\\nconst div = document.createElement('div');\\ndocument.body.appendChild(div);\\ndiv.style.position = 'absolute';\\ndiv.style.width = '40px';\\ndiv.style.height = '40px';\\ndiv.style.backgroundColor = 'lime';\\ndiv.style.transform = 'translate3d(10px, 0, 0)';\\n\\ntween(10, 400, 4000).subscribe(x => {\\n    div.style.transform = `translate3d(${x}px, 0, 0)`;\\n});\\n\"))), mdx(Footer, {\n    mdxType: \"Footer\"\n  })), mdx(\"hr\", null), mdx(Styles, {\n    mdxType: \"Styles\"\n  }), mdx(\"main\", null, mdx(\"div\", {\n    style: {\n      \"display\": \"flex\",\n      \"flexDirection\": \"column\",\n      \"height\": \"100%\",\n      \"alignItems\": \"center\"\n    }\n  }, mdx(\"h1\", null, \" Show it to me\"), mdx(AnimationFrameExample, {\n    mdxType: \"AnimationFrameExample\"\n  })), mdx(Footer, {\n    mdxType: \"Footer\"\n  })), mdx(\"hr\", null), mdx(Styles, {\n    mdxType: \"Styles\"\n  }), mdx(\"main\", null, mdx(CodeSurfer, {\n    theme: vsDarkReal,\n    mdxType: \"CodeSurfer\"\n  }, mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-ts\",\n    \"metastring\": \"1:8 file=./code/concat-with.ts title=\\\"Changes for concat Operator\\\"\",\n    \"1:8\": true,\n    \"file\": \"./code/concat-with.ts\",\n    \"title\": \"\\\"Changes\",\n    \"for\": true,\n    \"concat\": true,\n    \"Operator\\\"\": true\n  }), \"import { concat, of } from 'rxjs';\\n\\nconst hello$ = of('hello');\\nconst world$ = of('world');\\n\\nconcat(hello$, world$).subscribe(console.log);\\n// hello\\n// world\\n\\nimport { concatWith } from 'rxjs/operators';\\n\\nhello$.pipe(\\n    concatWith(world$)\\n).subscribe(console.log);\\n// hello\\n// world\\n\")), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-ts\",\n    \"metastring\": \"10:16 file=./code/concat-with.ts title=\\\"new concatWith Operator\\\"\",\n    \"10:16\": true,\n    \"file\": \"./code/concat-with.ts\",\n    \"title\": \"\\\"new\",\n    \"concatWith\": true,\n    \"Operator\\\"\": true\n  }), \"import { concat, of } from 'rxjs';\\n\\nconst hello$ = of('hello');\\nconst world$ = of('world');\\n\\nconcat(hello$, world$).subscribe(console.log);\\n// hello\\n// world\\n\\nimport { concatWith } from 'rxjs/operators';\\n\\nhello$.pipe(\\n    concatWith(world$)\\n).subscribe(console.log);\\n// hello\\n// world\\n\"))), mdx(Footer, {\n    mdxType: \"Footer\"\n  })), mdx(\"hr\", null), mdx(Styles, {\n    mdxType: \"Styles\"\n  }), mdx(\"main\", null, mdx(\"div\", {\n    style: {\n      \"display\": \"flex\",\n      \"flexDirection\": \"column\",\n      \"height\": \"100%\",\n      \"alignItems\": \"center\"\n    }\n  }, mdx(\"h1\", null, \"Summary\")), mdx(Footer, {\n    mdxType: \"Footer\"\n  })), mdx(\"hr\", null), mdx(Styles, {\n    mdxType: \"Styles\"\n  }), mdx(\"main\", null, mdx(TextSplit, {\n    image: practiceGif,\n    alt: \"puppy practicing swimming\",\n    mdxType: \"TextSplit\"\n  }, mdx(\"h1\", null, \" Practice with ... \"), mdx(\"ul\", null, mdx(\"li\", null, \" Redo the same \"), mdx(\"li\", null, \" Drag N' Drop \"), mdx(\"li\", null, \" Typeahead Search \"), mdx(\"li\", null, \" Longpolling \"))), mdx(Footer, {\n    mdxType: \"Footer\"\n  })), mdx(\"hr\", null), mdx(Styles, {\n    mdxType: \"Styles\"\n  }), mdx(\"main\", null, mdx(Links, {\n    mdxType: \"Links\"\n  }), mdx(Footer, {\n    mdxType: \"Footer\"\n  })), mdx(\"hr\", null), mdx(Styles, {\n    mdxType: \"Styles\"\n  }), mdx(\"main\", null, mdx(End, {\n    mdxType: \"End\"\n  })), mdx(\"hr\", null));\n}\n;\nMDXContent.isMDXComponent = true;"}},"pageContext":{"matchPath":"/*","isCreatedByStatefulCreatePages":false,"id":"369025ef-a512-5584-9dcc-c6cdccae4bd4","slug":"","title":""}}}